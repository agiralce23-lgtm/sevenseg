<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ認識 Webアプリ v15（TFJS学習モデル / 入力前処理つき）</title>
<style>
  body{font-family:system-ui,-apple-system,sans-serif;margin:0;background:#111;color:#eee}
  .wrap{display:flex;flex-direction:column;gap:10px;padding:10px;max-width:1200px;margin:0 auto}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button,select,input{font-size:16px;padding:8px 10px}
  .stage{position:relative;width:100%;aspect-ratio:16/9;background:#000;overflow:hidden;border-radius:10px}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  .roi{position:absolute;border:2px solid rgba(255,0,0,.9);box-shadow:0 0 0 9999px rgba(0,0,0,.35);border-radius:8px;pointer-events:none}
  .panel{background:#1b1b1b;padding:10px;border-radius:10px}
  .k{color:#9ad}
  .big{font-size:36px;font-weight:900;letter-spacing:.5px;display:flex;align-items:center;gap:10px}
  .sub{font-size:14px;color:#cfcfcf;margin-top:4px}
  .hint{color:#bbb;font-size:13px;line-height:1.45}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:10px}
  @media (max-width:920px){.grid{grid-template-columns:1fr}}
  .chip{display:flex;align-items:center;gap:6px;background:#222;padding:6px 8px;border-radius:999px}
  details{background:#151515;border-radius:10px;padding:8px 10px}
  details summary{cursor:pointer}
  .kv{display:grid;grid-template-columns:180px 1fr 70px;gap:8px;align-items:center;margin-top:8px}
  .kv label{color:#bbb;font-size:13px}
  .kv input[type=range]{width:100%}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .lamp{width:12px;height:12px;border-radius:999px;background:#555;box-shadow:0 0 0 2px rgba(255,255,255,.08) inset}
  .lamp.green{background:#1fe36d}
  .lamp.yellow{background:#ffd34d}
  .btn{background:#2a2a2a;border:1px solid #3a3a3a;color:#fff;border-radius:10px}
  .btn:active{transform:translateY(1px)}
  .smallinp{width:90px;padding:6px 8px;border-radius:8px;border:1px solid #333;background:#101010;color:#fff}
  .warn{color:#ffdf8a}
  .digits{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .digcard{background:#121212;border:1px solid #2b2b2b;border-radius:10px;padding:8px}
  .digcard canvas{display:block;width:72px;height:72px;border-radius:8px;background:#000}
  .digmeta{margin-top:6px;font-size:12px;color:#cfcfcf}
</style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.20.0/dist/tf-backend-wasm.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart" class="btn">カメラ開始</button>
    <button id="btnStop" class="btn" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>
    <span class="chip"><input id="lockBack" type="checkbox" checked>背面固定</span>

    <span class="chip"><input id="useML" type="checkbox" checked>学習モデル使用</span>
    <button id="btnLoadModel" class="btn" type="button">モデル読込</button>

    <label>推論間隔(ms)</label>
    <input id="anMs" type="range" min="80" max="400" step="10" value="140">
    <span id="anMsVal" class="mono">140</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="last" selected>最後の1桁前（xxx.x）</option>
      <option value="none">なし</option>
    </select>

    <span class="chip"><input id="stabilize" type="checkbox" checked>ちらつき防止</span>
    <span class="chip"><input id="hold" type="checkbox" checked>確定値ホールド</span>
  </div>

  <details open>
    <summary>入力前処理（ここが「全部8」対策の本丸）</summary>

    <div class="row" style="margin-top:8px">
      <label>入力モード</label>
      <select id="preMode">
        <option value="raw" selected>raw（そのままグレースケール）</option>
        <option value="invert">invert（白黒反転）</option>
        <option value="otsu">otsu（二値化:自動しきい値）</option>
        <option value="otsu_inv">otsu+invert（二値化して反転）</option>
      </select>

      <span class="chip"><input id="autoInv" type="checkbox" checked>自動反転（平均で判定）</span>
      <span class="chip"><input id="norm01" type="checkbox" checked>0..1正規化</span>

      <span class="chip">γ <input id="gamma" class="smallinp" type="number" step="0.1" value="1.0"></span>
      <span class="chip">コントラスト <input id="contrast" class="smallinp" type="number" step="0.1" value="1.0"></span>
    </div>

    <div class="kv"><label>左右マージン（%）</label><input id="mx" type="range" min="0" max="40" step="1" value="12"><span id="mxv"></span></div>
    <div class="kv"><label>上下マージン（%）</label><input id="my" type="range" min="0" max="40" step="1" value="10"><span id="myv"></span></div>

    <div class="hint warn" style="margin-top:8px">
      「全部 888.8」は、だいたい <b>前処理の極性（黒セグ/白セグ）</b> か <b>桁切り出し</b> の不一致で起きます。<br>
      まずは <b>入力モード</b> を <b>otsu</b> と <b>otsu+invert</b> で切り替え、下の「桁プレビュー」が “数字っぽく見える” 方に合わせてください。
    </div>
  </details>

  <details open>
    <summary>安定化（確定表示）</summary>
    <div class="kv"><label>確定に必要な連続フレーム</label><input id="needFrames" type="range" min="1" max="20" step="1" value="6"><span id="needFramesVal"></span></div>
    <div class="kv"><label>確定に必要な信頼度</label><input id="needConf" type="range" min="0.20" max="0.99" step="0.01" value="0.60"><span id="needConfVal"></span></div>
    <div class="kv"><label>失敗許容（ms）</label><input id="graceMs" type="range" min="0" max="2500" step="50" value="900"><span id="graceMsVal"></span></div>
    <div class="row" style="margin-top:8px">
      <span class="chip">範囲 <input id="minVal" class="smallinp" type="number" step="0.1" value="10"> ～ <input id="maxVal" class="smallinp" type="number" step="0.1" value="250"></span>
      <span class="chip"><input id="force1dp" type="checkbox" checked>小数1桁に揃える</span>
      <span class="chip"><input id="wasm" type="checkbox" checked>TFJS WASM（iPhone安定）</span>
    </div>
  </details>

  <details>
    <summary>ROI調整（1回合わせたら保存）</summary>
    <div class="kv"><label>X</label><input id="roiX" type="range" min="0" max="1" step="0.01"><span id="roiXv"></span></div>
    <div class="kv"><label>Y</label><input id="roiY" type="range" min="0" max="1" step="0.01"><span id="roiYv"></span></div>
    <div class="kv"><label>W</label><input id="roiW" type="range" min="0.05" max="1" step="0.01"><span id="roiWv"></span></div>
    <div class="kv"><label>H</label><input id="roiH" type="range" min="0.05" max="1" step="0.01"><span id="roiHv"></span></div>
    <div class="row" style="margin-top:8px">
      <button id="btnRoiReset" type="button" class="btn">ROIリセット</button>
    </div>
    <div class="hint" style="margin-top:6px">
      ROIは「表示窓だけ」に。周囲の印字が入るほど誤判定が増えます。
    </div>
  </details>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div id="roi" class="roi"></div>
    </div>

    <div class="panel">
      <div><span class="k">表示（確定）</span></div>
      <div class="big"><span id="lamp" class="lamp"></span><span id="out">—</span></div>
      <div id="candLine" class="sub mono">候補: —</div>
      <div class="hint mono" id="dbg"></div>
      <div class="row" style="margin-top:10px">
        <button id="btnCopy" class="btn" type="button">確定値をコピー</button>
      </div>
      <div class="hint mono" id="mlState" style="margin-top:6px">ml: not loaded</div>

      <div class="digits" id="digPrev"></div>

      <hr style="border:0;border-top:1px solid #333;margin:10px 0">
      <div class="hint">
        ・「桁プレビュー」が数字っぽく見える入力モードに合わせると一気に直ります。<br>
        ・それでも全部8なら、学習データが “1桁切り出し” になってない（全体画像を入れた等）の可能性が高いです。<br>
      </div>
    </div>
  </div>

  <canvas id="work" style="display:none"></canvas>
  <canvas id="dig" style="display:none"></canvas>
</div>

<script>
const $ = (id)=>document.getElementById(id);

const video=$("video"), overlay=$("overlay"), work=$("work"), dig=$("dig");
const ctxO = overlay.getContext('2d',{willReadFrequently:true});
const ctxW = work.getContext('2d',{willReadFrequently:true});
const ctxD = dig.getContext('2d',{willReadFrequently:true});

const btnStart=$("btnStart"), btnStop=$("btnStop"), selCam=$("selCam");
const lockBack=$("lockBack");

const useMLEl=$("useML"), btnLoadModel=$("btnLoadModel");
const anMsEl=$("anMs"), anMsVal=$("anMsVal");
const digitsEl=$("digits"), decEl=$("decimal");

const stabilizeEl=$("stabilize"), holdEl=$("hold");
const needFramesEl=$("needFrames"), needFramesVal=$("needFramesVal");
const needConfEl=$("needConf"), needConfVal=$("needConfVal");
const graceMsEl=$("graceMs"), graceMsVal=$("graceMsVal");
const minValEl=$("minVal"), maxValEl=$("maxVal"), force1dpEl=$("force1dp");
const wasmEl=$("wasm");

const preModeEl=$("preMode"), autoInvEl=$("autoInv"), norm01El=$("norm01");
const gammaEl=$("gamma"), contrastEl=$("contrast");
const mxEl=$("mx"), myEl=$("my"), mxv=$("mxv"), myv=$("myv");

const outEl=$("out"), candLine=$("candLine"), dbgEl=$("dbg"), roiEl=$("roi"), lampEl=$("lamp"), btnCopy=$("btnCopy");
const mlStateEl=$("mlState"), digPrev=$("digPrev");
const roiX=$("roiX"), roiY=$("roiY"), roiW=$("roiW"), roiH=$("roiH");
const roiXv=$("roiXv"), roiYv=$("roiYv"), roiWv=$("roiWv"), roiHv=$("roiHv");
const btnRoiReset=$("btnRoiReset");

let stream=null, rafId=null;

const LS={
  cam:"sevenseg_cam_deviceid", lock:"sevenseg_lockback", roi:"sevenseg_roi_v15",
  useML:"sevenseg_useml", an:"sevenseg_anms", digits:"sevenseg_digits", dec:"sevenseg_dec",
  stab:"sevenseg_stab", hold:"sevenseg_hold", nf:"sevenseg_needframes", nc:"sevenseg_needconf", gm:"sevenseg_gracems",
  minv:"sevenseg_minval", maxv:"sevenseg_maxval", force:"sevenseg_force1dp", wasm:"sevenseg_wasm",
  model:"sevenseg_model_url",
  premode:"sevenseg_premode", autoinv:"sevenseg_autoinv", norm01:"sevenseg_norm01", gamma:"sevenseg_gamma", contrast:"sevenseg_contrast",
  mx:"sevenseg_mx", my:"sevenseg_my"
};

function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function clamp01(v){return clamp(v,0,1)}
function setLamp(state){
  lampEl.classList.remove("green","yellow");
  if(state==="green") lampEl.classList.add("green");
  if(state==="yellow") lampEl.classList.add("yellow");
}
function setRoiBox(){
  const stage=roiEl.parentElement;
  const r=stage.getBoundingClientRect();
  roiEl.style.left=(ROI.x*r.width)+"px";
  roiEl.style.top=(ROI.y*r.height)+"px";
  roiEl.style.width=(ROI.w*r.width)+"px";
  roiEl.style.height=(ROI.h*r.height)+"px";
}
window.addEventListener('resize', setRoiBox);

// ROI
const defaultRoi={x:0.18,y:0.44,w:0.64,h:0.18};
let ROI=loadROI();
function loadROI(){
  try{
    const s=localStorage.getItem(LS.roi); if(!s) return {...defaultRoi};
    const o=JSON.parse(s);
    return {x:clamp01(+o.x),y:clamp01(+o.y),w:clamp01(+o.w),h:clamp01(+o.h)};
  }catch(_){return {...defaultRoi}}
}
function saveROI(){localStorage.setItem(LS.roi,JSON.stringify(ROI))}

function syncLabels(){
  anMsVal.textContent=String(anMsEl.value);
  needFramesVal.textContent=String(needFramesEl.value);
  needConfVal.textContent=Number(needConfEl.value).toFixed(2);
  graceMsVal.textContent=String(graceMsEl.value);

  roiX.value=ROI.x; roiY.value=ROI.y; roiW.value=ROI.w; roiH.value=ROI.h;
  roiXv.textContent=ROI.x.toFixed(2);
  roiYv.textContent=ROI.y.toFixed(2);
  roiWv.textContent=ROI.w.toFixed(2);
  roiHv.textContent=ROI.h.toFixed(2);

  mxv.textContent=mxEl.value+"%";
  myv.textContent=myEl.value+"%";
}
function bindRoi(sl,key){
  sl.addEventListener('input', ()=>{
    ROI[key]=clamp01(parseFloat(sl.value));
    if(key==="w") ROI.w=Math.max(0.05,ROI.w);
    if(key==="h") ROI.h=Math.max(0.05,ROI.h);
    ROI.x=clamp01(Math.min(ROI.x,1-ROI.w));
    ROI.y=clamp01(Math.min(ROI.y,1-ROI.h));
    saveROI(); syncLabels(); setRoiBox();
  });
}
bindRoi(roiX,"x"); bindRoi(roiY,"y"); bindRoi(roiW,"w"); bindRoi(roiH,"h");
btnRoiReset.onclick=()=>{ ROI={...defaultRoi}; saveROI(); syncLabels(); setRoiBox(); };

// settings restore
function restore(){
  lockBack.checked=(localStorage.getItem(LS.lock)??"1")==="1";
  selCam.value=localStorage.getItem(LS.cam)||"";
  useMLEl.checked=(localStorage.getItem(LS.useML)??"1")==="1";
  anMsEl.value=(localStorage.getItem(LS.an)??"140");
  digitsEl.value=(localStorage.getItem(LS.digits)??"4");
  decEl.value=(localStorage.getItem(LS.dec)??"last");

  stabilizeEl.checked=(localStorage.getItem(LS.stab)??"1")==="1";
  holdEl.checked=(localStorage.getItem(LS.hold)??"1")==="1";
  needFramesEl.value=(localStorage.getItem(LS.nf)??"6");
  needConfEl.value=(localStorage.getItem(LS.nc)??"0.60");
  graceMsEl.value=(localStorage.getItem(LS.gm)??"900");
  minValEl.value=(localStorage.getItem(LS.minv)??"10");
  maxValEl.value=(localStorage.getItem(LS.maxv)??"250");
  force1dpEl.checked=(localStorage.getItem(LS.force)??"1")==="1";
  wasmEl.checked=(localStorage.getItem(LS.wasm)??"1")==="1";

  preModeEl.value=(localStorage.getItem(LS.premode)??"raw");
  autoInvEl.checked=(localStorage.getItem(LS.autoinv)??"1")==="1";
  norm01El.checked=(localStorage.getItem(LS.norm01)??"1")==="1";
  gammaEl.value=(localStorage.getItem(LS.gamma)??"1.0");
  contrastEl.value=(localStorage.getItem(LS.contrast)??"1.0");
  mxEl.value=(localStorage.getItem(LS.mx)??"12");
  myEl.value=(localStorage.getItem(LS.my)??"10");

  syncLabels();
}
restore();

function persist(){
  lockBack.onchange=()=>localStorage.setItem(LS.lock, lockBack.checked?"1":"0");
  useMLEl.onchange=()=>localStorage.setItem(LS.useML, useMLEl.checked?"1":"0");
  anMsEl.oninput=()=>{localStorage.setItem(LS.an,anMsEl.value); syncLabels();}
  digitsEl.onchange=()=>localStorage.setItem(LS.digits,digitsEl.value);
  decEl.onchange=()=>localStorage.setItem(LS.dec,decEl.value);
  stabilizeEl.onchange=()=>localStorage.setItem(LS.stab, stabilizeEl.checked?"1":"0");
  holdEl.onchange=()=>localStorage.setItem(LS.hold, holdEl.checked?"1":"0");
  needFramesEl.oninput=()=>{localStorage.setItem(LS.nf,needFramesEl.value); syncLabels();}
  needConfEl.oninput=()=>{localStorage.setItem(LS.nc,needConfEl.value); syncLabels();}
  graceMsEl.oninput=()=>{localStorage.setItem(LS.gm,graceMsEl.value); syncLabels();}
  minValEl.onchange=()=>localStorage.setItem(LS.minv,minValEl.value);
  maxValEl.onchange=()=>localStorage.setItem(LS.maxv,maxValEl.value);
  force1dpEl.onchange=()=>localStorage.setItem(LS.force, force1dpEl.checked?"1":"0");
  wasmEl.onchange=()=>localStorage.setItem(LS.wasm, wasmEl.checked?"1":"0");

  preModeEl.onchange=()=>localStorage.setItem(LS.premode, preModeEl.value);
  autoInvEl.onchange=()=>localStorage.setItem(LS.autoinv, autoInvEl.checked?"1":"0");
  norm01El.onchange=()=>localStorage.setItem(LS.norm01, norm01El.checked?"1":"0");
  gammaEl.onchange=()=>localStorage.setItem(LS.gamma, gammaEl.value);
  contrastEl.onchange=()=>localStorage.setItem(LS.contrast, contrastEl.value);
  mxEl.oninput=()=>{localStorage.setItem(LS.mx, mxEl.value); syncLabels();}
  myEl.oninput=()=>{localStorage.setItem(LS.my, myEl.value); syncLabels();}
}
persist();

// camera list
function isBackLabel(label){ return /(back|rear|environment|背面|リア|後ろ)/i.test(label||""); }
async function listCams({preserve=true,autoPickBack=true}={}){
  const prev=preserve?selCam.value:"";
  const saved=localStorage.getItem(LS.cam)||"";
  const devices=await navigator.mediaDevices.enumerateDevices();
  const cams=devices.filter(d=>d.kind==="videoinput");
  selCam.innerHTML="";
  cams.forEach((c,i)=>{
    const opt=document.createElement("option");
    opt.value=c.deviceId;
    opt.textContent=c.label||`Camera ${i+1}`;
    selCam.appendChild(opt);
  });
  if([...selCam.options].some(o=>o.value===prev)){ selCam.value=prev; return;}
  if([...selCam.options].some(o=>o.value===saved)){ selCam.value=saved; return;}
  if(autoPickBack && lockBack.checked){
    const back=[...selCam.options].find(o=>isBackLabel(o.textContent));
    if(back){ selCam.value=back.value; return; }
  }
  if(selCam.options.length) selCam.selectedIndex=0;
}
selCam.onchange=()=>localStorage.setItem(LS.cam, selCam.value||"");

// start/stop
async function startCamera(){
  await listCams({preserve:true,autoPickBack:false});
  try{
    const tmp=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:lockBack.checked?"environment":"user"}},audio:false});
    tmp.getTracks().forEach(t=>t.stop());
  }catch(e){}
  await listCams({preserve:true,autoPickBack:true});

  const deviceId=selCam.value||undefined;
  stream=await navigator.mediaDevices.getUserMedia({
    video:{
      deviceId: deviceId?{exact:deviceId}:undefined,
      facingMode: deviceId?undefined:{ideal:lockBack.checked?"environment":"user"},
      width:{ideal:1280}, height:{ideal:720}
    },
    audio:false
  });

  video.srcObject=stream;
  await video.play();

  btnStart.disabled=true;
  btnStop.disabled=false;

  overlay.width=video.videoWidth;
  overlay.height=video.videoHeight;

  setRoiBox();
  resetStabilizer();
  buildDigitPreview();
  loop();
}
function stopCamera(){
  cancelAnimationFrame(rafId); rafId=null;
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  video.pause(); video.srcObject=null;

  btnStart.disabled=false;
  btnStop.disabled=true;

  outEl.textContent="—";
  candLine.textContent="候補: —";
  dbgEl.textContent="";
  setLamp("yellow");
}
btnStart.onclick=async()=>{ try{ await startCamera(); }catch(e){ alert("カメラ開始失敗: "+(e?.message||e)); } };
btnStop.onclick=()=>stopCamera();
selCam.onchange=async()=>{
  localStorage.setItem(LS.cam, selCam.value||"");
  if(!stream) return;
  stopCamera();
  await new Promise(r=>setTimeout(r,200));
  btnStart.onclick();
};

// helpers
function toFixed1dp(text){
  if(!force1dpEl.checked || !text) return text;
  if(text.includes(".")) return text;
  return text + ".0";
}
function passesGate(text){
  if(!text) return false;
  const v=parseFloat(text);
  const minV=parseFloat(minValEl.value||"0"), maxV=parseFloat(maxValEl.value||"9999");
  if(Number.isNaN(v)) return false;
  if(v<minV || v>maxV) return false;
  return true;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function setGammaContrast(x){
  const g = parseFloat(gammaEl.value||"1.0");
  const c = parseFloat(contrastEl.value||"1.0");
  let y = x;
  if(g !== 1.0){
    y = Math.pow(clamp01(y), 1.0/g);
  }
  if(c !== 1.0){
    y = clamp01((y-0.5)*c + 0.5);
  }
  return y;
}
btnCopy.onclick=async()=>{
  const t=stableText||outEl.textContent;
  if(!t||t==="—") return;
  try{ await navigator.clipboard.writeText(t); }
  catch(_){ prompt("コピーして使ってください:", t); }
};

// ===== ML model (digit classifier) =====
let model=null;
let modelReady=false;

async function initTF(){
  try{
    if(wasmEl.checked){
      const wasmPath = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.20.0/dist/";
      tf.wasm.setWasmPaths(wasmPath);
      await tf.setBackend("wasm");
    }else{
      await tf.setBackend("webgl");
    }
    await tf.ready();
    return true;
  }catch(e){
    console.log(e);
    return false;
  }
}
async function loadModel(url){
  mlStateEl.textContent="ml: loading…";
  const ok = await initTF();
  if(!ok){ mlStateEl.textContent="ml: tf init failed"; return false; }
  try{
    model = await tf.loadLayersModel(url, {strict:true});
    const ish = model.inputs[0].shape; // [null,h,w,1]
    const h = ish[1]||32, w = ish[2]||32;
    tf.tidy(()=>model.predict(tf.zeros([1,h,w,1])).dispose());
    modelReady=true;
    mlStateEl.textContent=`ml: ready (backend=${tf.getBackend()} url=${url})`;
    return true;
  }catch(e){
    modelReady=false;
    mlStateEl.textContent="ml: load failed: "+(e?.message||e);
    return false;
  }
}
btnLoadModel.onclick=async()=>{
  const url = localStorage.getItem(LS.model) || "./model/model.json";
  const ok = await loadModel(url);
  if(ok) localStorage.setItem(LS.model, url);
};

// ==== digit preview UI ====
let digCanvases=[], digMeta=[];
function buildDigitPreview(){
  const n = parseInt(digitsEl.value,10);
  digPrev.innerHTML="";
  digCanvases=[]; digMeta=[];
  for(let i=0;i<n;i++){
    const card=document.createElement("div");
    card.className="digcard";
    const c=document.createElement("canvas");
    c.width=64; c.height=64;
    const m=document.createElement("div");
    m.className="digmeta mono";
    m.textContent=`#${i+1}: —`;
    card.appendChild(c);
    card.appendChild(m);
    digPrev.appendChild(card);
    digCanvases.push(c);
    digMeta.push(m);
  }
}
digitsEl.onchange=()=>{
  localStorage.setItem(LS.digits,digitsEl.value);
  buildDigitPreview();
};

// ===== preprocessing (Otsu) =====
function otsuThreshold(grayArr){
  const hist = new Uint32Array(256);
  for(let i=0;i<grayArr.length;i++){
    const v = Math.max(0, Math.min(255, (grayArr[i]*255)|0));
    hist[v]++;
  }
  const total = grayArr.length;
  let sum=0;
  for(let i=0;i<256;i++) sum += i*hist[i];

  let sumB=0, wB=0, wF=0;
  let varMax=0, threshold=128;

  for(let t=0;t<256;t++){
    wB += hist[t];
    if(wB===0) continue;
    wF = total - wB;
    if(wF===0) break;
    sumB += t*hist[t];
    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;
    const varBetween = wB*wF*(mB-mF)*(mB-mF);
    if(varBetween > varMax){
      varMax = varBetween;
      threshold = t;
    }
  }
  return threshold/255.0;
}

// digit crop → tensor + preview
function cropDigitToArray(previewCanvas, srcCanvas, sx, sy, sw, sh, outW, outH){
  const pctx = previewCanvas.getContext("2d",{willReadFrequently:true});
  pctx.imageSmoothingEnabled = false;
  pctx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  pctx.drawImage(srcCanvas, sx,sy,sw,sh, 0,0, previewCanvas.width, previewCanvas.height);

  dig.width=outW; dig.height=outH;
  ctxD.imageSmoothingEnabled = true;
  ctxD.clearRect(0,0,outW,outH);
  ctxD.drawImage(srcCanvas, sx,sy,sw,sh, 0,0,outW,outH);

  const d = ctxD.getImageData(0,0,outW,outH).data;
  const arr = new Float32Array(outW*outH);
  for(let i=0,p=0;i<arr.length;i++,p+=4){
    const r=d[p], g=d[p+1], b=d[p+2];
    let x = (0.299*r + 0.587*g + 0.114*b) / 255.0;
    x = setGammaContrast(x);
    arr[i]=x;
  }

  const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
  const autoInv = autoInvEl.checked;
  let preMode = preModeEl.value;
  let doAutoInvert = autoInv && (mean > 0.62);

  if(preMode==="invert") doAutoInvert = true;

  if(preMode==="otsu" || preMode==="otsu_inv"){
    const thr = otsuThreshold(arr);
    for(let i=0;i<arr.length;i++){
      arr[i] = (arr[i] < thr) ? 1.0 : 0.0;
    }
    if(preMode==="otsu_inv") doAutoInvert = !doAutoInvert;
  }

  if(doAutoInvert){
    for(let i=0;i<arr.length;i++) arr[i] = 1.0 - arr[i];
  }
  return {arr};
}

async function predictDigitsWithModel(srcCanvas, nDigits){
  if(!modelReady) return {text:null, conf:0, debug:"ml-not-ready"};
  const ish = model.inputs[0].shape;
  const H = ish[1]||32, W = ish[2]||32;

  const w0 = srcCanvas.width, h0 = srcCanvas.height;

  const mx = Math.floor(w0 * (parseInt(mxEl.value,10)/100));
  const my = Math.floor(h0 * (parseInt(myEl.value,10)/100));
  const x0 = mx, y0 = my;
  const ww = Math.max(10, w0 - mx*2);
  const hh = Math.max(10, h0 - my*2);
  const digitW = ww / nDigits;

  let s="", confs=[];
  for(let i=0;i<nDigits;i++){
    const dx = Math.floor(x0 + i*digitW);
    const dw = Math.max(1, Math.floor(digitW));
    const preview = digCanvases[i];

    const {arr} = cropDigitToArray(preview, srcCanvas, dx, y0, dw, hh, W, H);
    const t = tf.tensor4d(arr, [1,H,W,1]);

    const p = tf.tidy(()=>{
      const y = model.predict(t);
      const a = y.dataSync();
      return Array.from(a);
    });
    t.dispose();

    let bestI=0, bestV=p[0];
    for(let k=1;k<p.length;k++){ if(p[k]>bestV){bestV=p[k]; bestI=k;} }

    if(bestI===10) s += ""; else s += String(bestI);
    confs.push(bestV);

    digMeta[i].textContent = `#${i+1}: cls=${bestI} p=${bestV.toFixed(2)} mode=${preModeEl.value}`;
  }

  if(decEl.value==="last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
  }
  s = toFixed1dp(s);

  const ok=/^[0-9]+(\.[0-9]+)?$/.test(s);
  const conf = confs.length ? confs.reduce((a,b)=>a+b,0)/confs.length : 0;
  return {text: ok?s:null, conf, debug:`avgMaxP=${conf.toFixed(2)}`};
}

// ===== stabilizer =====
let lastCand=null, consec=0, stableText=null, stableConf=0, lastOkAt=0;
function resetStabilizer(){ lastCand=null; consec=0; stableText=null; stableConf=0; lastOkAt=0; setLamp("yellow"); }

// ===== loop =====
let lastAnalyzeAt=0;
function loop(){
  const now=performance.now();
  const interval=parseInt(anMsEl.value,10);

  ctxO.clearRect(0,0,overlay.width,overlay.height);

  const rx=Math.floor(ROI.x*overlay.width);
  const ry=Math.floor(ROI.y*overlay.height);
  const rw=Math.floor(ROI.w*overlay.width);
  const rh=Math.floor(ROI.h*overlay.height);

  ctxO.strokeStyle='rgba(255,0,0,.95)'; ctxO.lineWidth=3;
  ctxO.strokeRect(rx+1,ry+1,rw-2,rh-2);

  if(now-lastAnalyzeAt < interval){
    rafId=requestAnimationFrame(loop);
    return;
  }
  lastAnalyzeAt=now;

  work.width=rw; work.height=rh;
  ctxW.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);

  const nd=parseInt(digitsEl.value,10);

  if(useMLEl.checked && modelReady){
    predictDigitsWithModel(work, nd).then(res=>{
      applyCandidate(res.text, res.conf, res.debug);
    });
  }else{
    applyCandidate(null, 0, useMLEl.checked?"ml-not-ready":"ml-off");
  }

  rafId=requestAnimationFrame(loop);
}

function applyCandidate(candidate, conf, debug){
  candLine.textContent = `候補: ${candidate ?? "—"} (conf=${conf.toFixed(2)} / ${debug})`;

  const needFrames=parseInt(needFramesEl.value,10);
  const needConf=parseFloat(needConfEl.value);
  const graceMs=parseInt(graceMsEl.value,10);

  let acceptable = (candidate !== null) && (conf >= needConf) && passesGate(candidate);

  if(acceptable){
    lastOkAt = performance.now();
    if(candidate === lastCand) consec++;
    else { lastCand=candidate; consec=1; }

    if(!stabilizeEl.checked){
      stableText=candidate; stableConf=conf; outEl.textContent=stableText; setLamp("green");
    }else{
      if(consec >= needFrames){
        stableText=candidate; stableConf=conf; outEl.textContent=stableText; setLamp("green");
      }else{
        if(!holdEl.checked) outEl.textContent="—";
        else if(stableText) outEl.textContent=stableText;
        setLamp("yellow");
      }
    }
  }else{
    lastCand=null; consec=0;
    const now=performance.now();
    const withinGrace = stableText && (now - lastOkAt) <= graceMs;
    if(withinGrace && holdEl.checked){
      outEl.textContent=stableText;
      setLamp("green");
    }else{
      if(!holdEl.checked) outEl.textContent="—";
      else if(stableText) outEl.textContent=stableText;
      setLamp("yellow");
    }
  }

  const camLabel = selCam.selectedOptions?.[0]?.textContent || "";
  dbgEl.textContent =
    `ml=${useMLEl.checked?1:0} ready=${modelReady?1:0} premode=${preModeEl.value} autoInv=${autoInvEl.checked?1:0} `+
    `conf=${conf.toFixed(2)} needConf=${Number(needConfEl.value).toFixed(2)} `+
    `stable=${stabilizeEl.checked?1:0} consec=${consec}/${needFrames} grace=${graceMs}ms | cam="${camLabel}"`;
}

// init
navigator.mediaDevices?.addEventListener?.('devicechange', ()=>listCams({preserve:true,autoPickBack:true}));
listCams({preserve:true,autoPickBack:true}).catch(()=>{});
setRoiBox(); syncLabels(); buildDigitPreview(); setLamp("yellow");
</script>
</body>
</html>
