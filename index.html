<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ認識 Webアプリ v14（学習モデル: TFJS / OCRなし）</title>
<style>
  body{font-family:system-ui,-apple-system,sans-serif;margin:0;background:#111;color:#eee}
  .wrap{display:flex;flex-direction:column;gap:10px;padding:10px;max-width:1100px;margin:0 auto}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button,select,input{font-size:16px;padding:8px 10px}
  .stage{position:relative;width:100%;aspect-ratio:16/9;background:#000;overflow:hidden;border-radius:10px}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  .roi{position:absolute;border:2px solid rgba(255,0,0,.9);box-shadow:0 0 0 9999px rgba(0,0,0,.35);border-radius:8px;pointer-events:none}
  .panel{background:#1b1b1b;padding:10px;border-radius:10px}
  .k{color:#9ad}
  .big{font-size:36px;font-weight:900;letter-spacing:.5px;display:flex;align-items:center;gap:10px}
  .sub{font-size:14px;color:#cfcfcf;margin-top:4px}
  .hint{color:#bbb;font-size:13px;line-height:1.45}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:10px}
  @media (max-width:820px){.grid{grid-template-columns:1fr}}
  .chip{display:flex;align-items:center;gap:6px;background:#222;padding:6px 8px;border-radius:999px}
  details{background:#151515;border-radius:10px;padding:8px 10px}
  details summary{cursor:pointer}
  .kv{display:grid;grid-template-columns:160px 1fr 70px;gap:8px;align-items:center;margin-top:8px}
  .kv label{color:#bbb;font-size:13px}
  .kv input[type=range]{width:100%}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .lamp{width:12px;height:12px;border-radius:999px;background:#555;box-shadow:0 0 0 2px rgba(255,255,255,.08) inset}
  .lamp.green{background:#1fe36d}
  .lamp.yellow{background:#ffd34d}
  .lamp.cyan{background:#33d6ff}
  .btn{background:#2a2a2a;border:1px solid #3a3a3a;color:#fff;border-radius:10px}
  .btn:active{transform:translateY(1px)}
  .smallinp{width:96px;padding:6px 8px;border-radius:8px;border:1px solid #333;background:#101010;color:#fff}
  .warn{color:#ffdf8a}
</style>

<!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.20.0/dist/tf-backend-wasm.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart" class="btn">カメラ開始</button>
    <button id="btnStop" class="btn" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>

    <span class="chip"><input id="lockBack" type="checkbox" checked>背面固定</span>

    <span class="chip"><input id="useML" type="checkbox" checked>学習モデル使用</span>
    <button id="btnLoadModel" class="btn" type="button">モデル読込</button>

    <label>推論間隔(ms)</label>
    <input id="anMs" type="range" min="60" max="300" step="10" value="120">
    <span id="anMsVal" class="mono">120</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="last" selected>最後の1桁前（xxx.x）</option>
      <option value="none">なし</option>
    </select>

    <span class="chip"><input id="stabilize" type="checkbox" checked>ちらつき防止</span>
    <span class="chip"><input id="hold" type="checkbox" checked>確定値ホールド</span>
  </div>

  <details open>
    <summary>安定化（確定表示）</summary>
    <div class="kv"><label>確定に必要な連続フレーム</label><input id="needFrames" type="range" min="1" max="20" step="1" value="6"><span id="needFramesVal"></span></div>
    <div class="kv"><label>確定に必要な信頼度</label><input id="needConf" type="range" min="0.30" max="0.99" step="0.01" value="0.70"><span id="needConfVal"></span></div>
    <div class="kv"><label>失敗許容（ms）</label><input id="graceMs" type="range" min="0" max="2500" step="50" value="800"><span id="graceMsVal"></span></div>

    <div class="row" style="margin-top:8px">
      <span class="chip">範囲 <input id="minVal" class="smallinp" type="number" step="0.1" value="10"> ～ <input id="maxVal" class="smallinp" type="number" step="0.1" value="250"></span>
      <span class="chip"><input id="force1dp" type="checkbox" checked>小数1桁に揃える</span>
      <span class="chip"><input id="wasm" type="checkbox" checked>TFJS WASM（iPhone安定）</span>
    </div>

    <div class="hint warn" style="margin-top:8px">
      この版は <b>OCR(Tesseract)なし</b>。学習モデル（TFJS）で「しきい値調整」を減らします。<br>
      <b>モデルファイル</b>は同じフォルダに <span class="mono">model/model.json</span> と <span class="mono">model/*.bin</span> を置いてください（https配信推奨）。
    </div>
  </details>

  <details>
    <summary>ROI調整（1回合わせたら保存）</summary>
    <div class="kv"><label>X</label><input id="roiX" type="range" min="0" max="1" step="0.01"><span id="roiXv"></span></div>
    <div class="kv"><label>Y</label><input id="roiY" type="range" min="0" max="1" step="0.01"><span id="roiYv"></span></div>
    <div class="kv"><label>W</label><input id="roiW" type="range" min="0.05" max="1" step="0.01"><span id="roiWv"></span></div>
    <div class="kv"><label>H</label><input id="roiH" type="range" min="0.05" max="1" step="0.01"><span id="roiHv"></span></div>
    <div class="row" style="margin-top:8px">
      <button id="btnRoiReset" type="button" class="btn">ROIリセット</button>
    </div>
    <div class="hint" style="margin-top:6px">
      ROIは「表示窓だけ」まで絞るほど精度UP（周囲の印刷文字を入れない）。
    </div>
  </details>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div id="roi" class="roi"></div>
    </div>
    <div class="panel">
      <div><span class="k">表示（確定）</span></div>
      <div class="big"><span id="lamp" class="lamp"></span><span id="out">—</span></div>
      <div id="candLine" class="sub mono">候補: —</div>
      <div class="hint mono" id="dbg"></div>
      <div class="row" style="margin-top:10px">
        <button id="btnCopy" class="btn" type="button">確定値をコピー</button>
      </div>
      <div class="hint mono" id="mlState" style="margin-top:6px">ml: not loaded</div>
      <hr style="border:0;border-top:1px solid #333;margin:10px 0">
      <div class="hint">
        ・緑＝確定（安定） / 黄＝未確定<br>
        ・学習モデルは「桁ごと」に分類します（0〜9、空白）。<br>
      </div>
    </div>
  </div>

  <canvas id="work" style="display:none"></canvas>
  <canvas id="dig" style="display:none"></canvas>
</div>

<script>
const $ = (id)=>document.getElementById(id);

const video=$("video"), overlay=$("overlay"), work=$("work"), dig=$("dig");
const ctxO = overlay.getContext('2d',{willReadFrequently:true});
const ctxW = work.getContext('2d',{willReadFrequently:true});
const ctxD = dig.getContext('2d',{willReadFrequently:true});

const btnStart=$("btnStart"), btnStop=$("btnStop"), selCam=$("selCam");
const lockBack=$("lockBack");

const useMLEl=$("useML"), btnLoadModel=$("btnLoadModel");
const anMsEl=$("anMs"), anMsVal=$("anMsVal");
const digitsEl=$("digits"), decEl=$("decimal");

const stabilizeEl=$("stabilize"), holdEl=$("hold");
const needFramesEl=$("needFrames"), needFramesVal=$("needFramesVal");
const needConfEl=$("needConf"), needConfVal=$("needConfVal");
const graceMsEl=$("graceMs"), graceMsVal=$("graceMsVal");
const minValEl=$("minVal"), maxValEl=$("maxVal"), force1dpEl=$("force1dp");
const wasmEl=$("wasm");

const outEl=$("out"), candLine=$("candLine"), dbgEl=$("dbg"), roiEl=$("roi"), lampEl=$("lamp"), btnCopy=$("btnCopy");
const mlStateEl=$("mlState");
const roiX=$("roiX"), roiY=$("roiY"), roiW=$("roiW"), roiH=$("roiH");
const roiXv=$("roiXv"), roiYv=$("roiYv"), roiWv=$("roiWv"), roiHv=$("roiHv");
const btnRoiReset=$("btnRoiReset");

let stream=null, rafId=null;

const LS={ cam:"sevenseg_cam_deviceid", lock:"sevenseg_lockback", roi:"sevenseg_roi_v14",
  useML:"sevenseg_useml", an:"sevenseg_anms", digits:"sevenseg_digits", dec:"sevenseg_dec",
  stab:"sevenseg_stab", hold:"sevenseg_hold", nf:"sevenseg_needframes", nc:"sevenseg_needconf", gm:"sevenseg_gracems",
  minv:"sevenseg_minval", maxv:"sevenseg_maxval", force:"sevenseg_force1dp", wasm:"sevenseg_wasm",
  model:"sevenseg_model_url"
};

function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function clamp01(v){return clamp(v,0,1)}
function setLamp(state){
  lampEl.classList.remove("green","yellow","cyan");
  if(state==="green") lampEl.classList.add("green");
  if(state==="yellow") lampEl.classList.add("yellow");
  if(state==="cyan") lampEl.classList.add("cyan");
}
function setRoiBox(){
  const stage=roiEl.parentElement;
  const r=stage.getBoundingClientRect();
  roiEl.style.left=(ROI.x*r.width)+"px";
  roiEl.style.top=(ROI.y*r.height)+"px";
  roiEl.style.width=(ROI.w*r.width)+"px";
  roiEl.style.height=(ROI.h*r.height)+"px";
}
window.addEventListener('resize', setRoiBox);

// ROI
const defaultRoi={x:0.18,y:0.44,w:0.64,h:0.18};
let ROI=loadROI();
function loadROI(){
  try{
    const s=localStorage.getItem(LS.roi); if(!s) return {...defaultRoi};
    const o=JSON.parse(s);
    return {x:clamp01(+o.x),y:clamp01(+o.y),w:clamp01(+o.w),h:clamp01(+o.h)};
  }catch(_){return {...defaultRoi}}
}
function saveROI(){localStorage.setItem(LS.roi,JSON.stringify(ROI))}

function syncLabels(){
  anMsVal.textContent=String(anMsEl.value);
  needFramesVal.textContent=String(needFramesEl.value);
  needConfVal.textContent=Number(needConfEl.value).toFixed(2);
  graceMsVal.textContent=String(graceMsEl.value);

  roiX.value=ROI.x; roiY.value=ROI.y; roiW.value=ROI.w; roiH.value=ROI.h;
  roiXv.textContent=ROI.x.toFixed(2);
  roiYv.textContent=ROI.y.toFixed(2);
  roiWv.textContent=ROI.w.toFixed(2);
  roiHv.textContent=ROI.h.toFixed(2);
}
function bindRoi(sl,key){
  sl.addEventListener('input', ()=>{
    ROI[key]=clamp01(parseFloat(sl.value));
    if(key==="w") ROI.w=Math.max(0.05,ROI.w);
    if(key==="h") ROI.h=Math.max(0.05,ROI.h);
    ROI.x=clamp01(Math.min(ROI.x,1-ROI.w));
    ROI.y=clamp01(Math.min(ROI.y,1-ROI.h));
    saveROI(); syncLabels(); setRoiBox();
  });
}
bindRoi(roiX,"x"); bindRoi(roiY,"y"); bindRoi(roiW,"w"); bindRoi(roiH,"h");
btnRoiReset.onclick=()=>{ ROI={...defaultRoi}; saveROI(); syncLabels(); setRoiBox(); };

// settings restore
function restore(){
  lockBack.checked=(localStorage.getItem(LS.lock)??"1")==="1";
  selCam.value=localStorage.getItem(LS.cam)||"";
  useMLEl.checked=(localStorage.getItem(LS.useML)??"1")==="1";
  anMsEl.value=(localStorage.getItem(LS.an)??"120");
  digitsEl.value=(localStorage.getItem(LS.digits)??"4");
  decEl.value=(localStorage.getItem(LS.dec)??"last");

  stabilizeEl.checked=(localStorage.getItem(LS.stab)??"1")==="1";
  holdEl.checked=(localStorage.getItem(LS.hold)??"1")==="1";
  needFramesEl.value=(localStorage.getItem(LS.nf)??"6");
  needConfEl.value=(localStorage.getItem(LS.nc)??"0.70");
  graceMsEl.value=(localStorage.getItem(LS.gm)??"800");
  minValEl.value=(localStorage.getItem(LS.minv)??"10");
  maxValEl.value=(localStorage.getItem(LS.maxv)??"250");
  force1dpEl.checked=(localStorage.getItem(LS.force)??"1")==="1";
  wasmEl.checked=(localStorage.getItem(LS.wasm)??"1")==="1";
  syncLabels();
}
restore();

function persist(){
  lockBack.onchange=()=>localStorage.setItem(LS.lock, lockBack.checked?"1":"0");
  useMLEl.onchange=()=>localStorage.setItem(LS.useML, useMLEl.checked?"1":"0");
  anMsEl.oninput=()=>{localStorage.setItem(LS.an,anMsEl.value); syncLabels();}
  digitsEl.onchange=()=>localStorage.setItem(LS.digits,digitsEl.value);
  decEl.onchange=()=>localStorage.setItem(LS.dec,decEl.value);
  stabilizeEl.onchange=()=>localStorage.setItem(LS.stab, stabilizeEl.checked?"1":"0");
  holdEl.onchange=()=>localStorage.setItem(LS.hold, holdEl.checked?"1":"0");
  needFramesEl.oninput=()=>{localStorage.setItem(LS.nf,needFramesEl.value); syncLabels();}
  needConfEl.oninput=()=>{localStorage.setItem(LS.nc,needConfEl.value); syncLabels();}
  graceMsEl.oninput=()=>{localStorage.setItem(LS.gm,graceMsEl.value); syncLabels();}
  minValEl.onchange=()=>localStorage.setItem(LS.minv,minValEl.value);
  maxValEl.onchange=()=>localStorage.setItem(LS.maxv,maxValEl.value);
  force1dpEl.onchange=()=>localStorage.setItem(LS.force, force1dpEl.checked?"1":"0");
  wasmEl.onchange=()=>localStorage.setItem(LS.wasm, wasmEl.checked?"1":"0");
}
persist();

// camera list
function isBackLabel(label){ return /(back|rear|environment|背面|リア|後ろ)/i.test(label||""); }
async function listCams({preserve=true,autoPickBack=true}={}){
  const prev=preserve?selCam.value:"";
  const saved=localStorage.getItem(LS.cam)||"";
  const devices=await navigator.mediaDevices.enumerateDevices();
  const cams=devices.filter(d=>d.kind==="videoinput");
  selCam.innerHTML="";
  cams.forEach((c,i)=>{
    const opt=document.createElement("option");
    opt.value=c.deviceId;
    opt.textContent=c.label||`Camera ${i+1}`;
    selCam.appendChild(opt);
  });
  if([...selCam.options].some(o=>o.value===prev)){ selCam.value=prev; return;}
  if([...selCam.options].some(o=>o.value===saved)){ selCam.value=saved; return;}
  if(autoPickBack && lockBack.checked){
    const back=[...selCam.options].find(o=>isBackLabel(o.textContent));
    if(back){ selCam.value=back.value; return; }
  }
  if(selCam.options.length) selCam.selectedIndex=0;
}
selCam.onchange=()=>localStorage.setItem(LS.cam, selCam.value||"");

// start/stop
async function startCamera(){
  await listCams({preserve:true,autoPickBack:false});
  try{
    const tmp=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:lockBack.checked?"environment":"user"}},audio:false});
    tmp.getTracks().forEach(t=>t.stop());
  }catch(e){}
  await listCams({preserve:true,autoPickBack:true});

  const deviceId=selCam.value||undefined;
  stream=await navigator.mediaDevices.getUserMedia({
    video:{
      deviceId: deviceId?{exact:deviceId}:undefined,
      facingMode: deviceId?undefined:{ideal:lockBack.checked?"environment":"user"},
      width:{ideal:1280}, height:{ideal:720}
    },
    audio:false
  });

  video.srcObject=stream;
  await video.play();

  btnStart.disabled=true;
  btnStop.disabled=false;

  overlay.width=video.videoWidth;
  overlay.height=video.videoHeight;

  setRoiBox();
  resetStabilizer();
  loop();
}
function stopCamera(){
  cancelAnimationFrame(rafId); rafId=null;
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  video.pause(); video.srcObject=null;

  btnStart.disabled=false;
  btnStop.disabled=true;

  outEl.textContent="—";
  candLine.textContent="候補: —";
  dbgEl.textContent="";
  setLamp("off");
}
btnStart.onclick=async()=>{ try{ await startCamera(); }catch(e){ alert("カメラ開始失敗: "+(e?.message||e)); } };
btnStop.onclick=()=>stopCamera();
selCam.onchange=async()=>{
  localStorage.setItem(LS.cam, selCam.value||"");
  if(!stream) return;
  stopCamera();
  await new Promise(r=>setTimeout(r,200));
  btnStart.onclick();
};

// helpers
function toFixed1dp(text){
  if(!force1dpEl.checked || !text) return text;
  if(text.includes(".")) return text;
  return text + ".0";
}
function passesGate(text){
  if(!text) return false;
  const v=parseFloat(text);
  const minV=parseFloat(minValEl.value||"0"), maxV=parseFloat(maxValEl.value||"9999");
  if(Number.isNaN(v)) return false;
  if(v<minV || v>maxV) return false;
  return true;
}
btnCopy.onclick=async()=>{
  const t=stableText||outEl.textContent;
  if(!t||t==="—") return;
  try{ await navigator.clipboard.writeText(t); }
  catch(_){ prompt("コピーして使ってください:", t); }
};

// ===== ML model (digit classifier) =====
// 想定: modelは (H,W,1) → 11クラス [0..9, blank] のsoftmax
let model=null;
let modelReady=false;

async function initTF(){
  try{
    if(wasmEl.checked){
      // wasm backend for iOS stability
      const wasmPath = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.20.0/dist/";
      tf.wasm.setWasmPaths(wasmPath);
      await tf.setBackend("wasm");
    }else{
      await tf.setBackend("webgl");
    }
    await tf.ready();
    return true;
  }catch(e){
    console.log(e);
    return false;
  }
}
async function loadModel(url){
  mlStateEl.textContent="ml: loading…";
  const ok = await initTF();
  if(!ok){ mlStateEl.textContent="ml: tf init failed"; return false; }
  try{
    model = await tf.loadLayersModel(url, {strict:true});
    // warmup
    const ish = model.inputs[0].shape; // [null,h,w,1]
    const h = ish[1]||32, w = ish[2]||32;
    tf.tidy(()=>model.predict(tf.zeros([1,h,w,1])).dispose());
    modelReady=true;
    mlStateEl.textContent=`ml: ready (backend=${tf.getBackend()} url=${url})`;
    return true;
  }catch(e){
    modelReady=false;
    mlStateEl.textContent="ml: load failed: "+(e?.message||e);
    return false;
  }
}
btnLoadModel.onclick=async()=>{
  const url = localStorage.getItem(LS.model) || "./model/model.json";
  const ok = await loadModel(url);
  if(ok) localStorage.setItem(LS.model, url);
};

// digit crop → tensor
function cropToTensorGray(imgData, x, y, w, h, outW, outH){
  // draw ROI digit to small canvas and read grayscale
  dig.width = outW; dig.height = outH;
  // put ROI image into temp canvas
  const tmp = document.createElement("canvas");
  tmp.width = imgData.width; tmp.height = imgData.height;
  const tctx = tmp.getContext("2d",{willReadFrequently:true});
  tctx.putImageData(imgData,0,0);
  ctxD.imageSmoothingEnabled = true;
  ctxD.clearRect(0,0,outW,outH);
  ctxD.drawImage(tmp, x,y,w,h, 0,0,outW,outH);
  const d = ctxD.getImageData(0,0,outW,outH).data;
  // normalize to 0..1 (grayscale)
  const arr = new Float32Array(outW*outH);
  for(let i=0,p=0;i<arr.length;i++,p+=4){
    const r=d[p], g=d[p+1], b=d[p+2];
    arr[i] = (0.299*r + 0.587*g + 0.114*b) / 255.0;
  }
  return tf.tensor4d(arr, [1,outH,outW,1]);
}

async function predictDigitsWithModel(imgData, nDigits){
  if(!modelReady) return {text:null, conf:0, debug:"ml-not-ready"};
  const ish = model.inputs[0].shape; // [null,h,w,1]
  const H = ish[1]||32, W = ish[2]||32;

  // equal-split inside ROI imageData
  // NOTE: ROIは「表示窓」基準。数字が中央寄りなら左右マージンを少し削る
  const w0 = imgData.width, h0 = imgData.height;
  const mx = Math.floor(w0 * 0.12); // 左右マージン（必要なら調整）
  const my = Math.floor(h0 * 0.10); // 上下マージン
  const x0 = mx, y0 = my;
  const ww = Math.max(10, w0 - mx*2);
  const hh = Math.max(10, h0 - my*2);
  const digitW = ww / nDigits;

  let s="", confs=[];
  for(let i=0;i<nDigits;i++){
    const dx = Math.floor(x0 + i*digitW);
    const dw = Math.floor(digitW);
    const t = cropToTensorGray(imgData, dx, y0, dw, hh, W, H);
    const {cls, prob} = tf.tidy(()=>{
      const y = model.predict(t);
      const p = y.dataSync();
      let bestI=0, bestV=p[0];
      for(let k=1;k<p.length;k++){ if(p[k]>bestV){bestV=p[k]; bestI=k;} }
      return {cls: bestI, prob: bestV};
    });
    t.dispose();
    if(cls===10) s += ""; // blank
    else s += String(cls);
    confs.push(prob);
  }

  // decimal
  const decMode = decEl.value;
  if(decMode==="last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
  }

  s = toFixed1dp(s);

  const ok=/^[0-9]+(\.[0-9]+)?$/.test(s);
  const conf = confs.length ? confs.reduce((a,b)=>a+b,0)/confs.length : 0;
  return {text: ok?s:null, conf, debug:`ml ok avgP=${conf.toFixed(2)}`};
}

// ===== stabilizer =====
let lastCand=null, consec=0, stableText=null, stableConf=0, lastOkAt=0;
function resetStabilizer(){ lastCand=null; consec=0; stableText=null; stableConf=0; lastOkAt=0; setLamp("off"); }

// ===== loop =====
let lastAnalyzeAt=0;

function loop(){
  const now=performance.now();
  const interval=parseInt(anMsEl.value,10);

  ctxO.clearRect(0,0,overlay.width,overlay.height);

  const rx=Math.floor(ROI.x*overlay.width);
  const ry=Math.floor(ROI.y*overlay.height);
  const rw=Math.floor(ROI.w*overlay.width);
  const rh=Math.floor(ROI.h*overlay.height);

  ctxO.strokeStyle='rgba(255,0,0,.95)'; ctxO.lineWidth=3;
  ctxO.strokeRect(rx+1,ry+1,rw-2,rh-2);

  if(now-lastAnalyzeAt < interval){
    rafId=requestAnimationFrame(loop);
    return;
  }
  lastAnalyzeAt=now;

  work.width=rw; work.height=rh;
  ctxW.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);
  const img=ctxW.getImageData(0,0,rw,rh);

  const nd=parseInt(digitsEl.value,10);

  // candidate (ML)
  let candidate=null, conf=0, debug="";

  if(useMLEl.checked){
    // NOTE: ML推論はasyncだけど、ここは軽量にするため await で直列（推論間隔で抑制）
    // iPhoneで重い場合は interval を上げてください。
    predictDigitsWithModel(img, nd).then(res=>{
      applyCandidate(res.text, res.conf, res.debug);
    });
  }else{
    // ML OFF の場合は未実装（必要なら従来の7セグ判定をここに戻せます）
    applyCandidate(null, 0, "ml-off");
  }

  rafId=requestAnimationFrame(loop);
}

function applyCandidate(candidate, conf, debug){
  candLine.textContent = `候補: ${candidate ?? "—"} (conf=${conf.toFixed(2)} / ${debug})`;

  const needFrames=parseInt(needFramesEl.value,10);
  const needConf=parseFloat(needConfEl.value);
  const graceMs=parseInt(graceMsEl.value,10);

  let acceptable = (candidate !== null) && (conf >= needConf) && passesGate(candidate);

  if(acceptable){
    lastOkAt = performance.now();
    if(candidate === lastCand) consec++;
    else { lastCand=candidate; consec=1; }

    if(!stabilizeEl.checked){
      stableText=candidate; stableConf=conf; outEl.textContent=stableText; setLamp("green");
    }else{
      if(consec >= needFrames){
        stableText=candidate; stableConf=conf; outEl.textContent=stableText; setLamp("green");
      }else{
        if(!holdEl.checked) outEl.textContent="—";
        else if(stableText) outEl.textContent=stableText;
        setLamp("yellow");
      }
    }
  }else{
    lastCand=null; consec=0;
    const now=performance.now();
    const withinGrace = stableText && (now - lastOkAt) <= graceMs;
    if(withinGrace && holdEl.checked){
      outEl.textContent=stableText;
      setLamp("green");
    }else{
      if(!holdEl.checked) outEl.textContent="—";
      else if(stableText) outEl.textContent=stableText;
      setLamp("yellow");
    }
  }

  const camLabel = selCam.selectedOptions?.[0]?.textContent || "";
  dbgEl.textContent =
    `ml=${useMLEl.checked?1:0} ready=${modelReady?1:0} conf=${conf.toFixed(2)} needConf=${Number(needConfEl.value).toFixed(2)} `+
    `stable=${stabilizeEl.checked?1:0} consec=${consec}/${needFrames} grace=${graceMs}ms | cam="${camLabel}"`;
}

// init
navigator.mediaDevices?.addEventListener?.('devicechange', ()=>listCams({preserve:true,autoPickBack:true}));
listCams({preserve:true,autoPickBack:true}).catch(()=>{});
setRoiBox(); syncLabels();
</script>
</body>
</html>
