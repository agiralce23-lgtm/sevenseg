<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ読み取り v20（7窓・横断窓＋角度）</title>
<style>
  body{font-family:system-ui,-apple-system,sans-serif;margin:0;background:#111;color:#eee}
  .wrap{max-width:1120px;margin:0 auto;padding:10px;display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button,select,input{font-size:16px;padding:8px 10px}
  .btn{background:#2a2a2a;border:1px solid #3a3a3a;color:#fff;border-radius:10px}
  .btn:active{transform:translateY(1px)}
  .chip{display:flex;align-items:center;gap:6px;background:#1c1c1c;border:1px solid #2a2a2a;padding:6px 8px;border-radius:999px}
  .stage{position:relative;width:100%;aspect-ratio:16/9;background:#000;overflow:hidden;border-radius:12px}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  .panel{background:#1b1b1b;border-radius:12px;padding:10px}
  .big{font-size:42px;font-weight:900;letter-spacing:.5px;display:flex;align-items:center;gap:10px}
  .lamp{width:12px;height:12px;border-radius:999px;background:#666;box-shadow:0 0 0 2px rgba(255,255,255,.08) inset}
  .lamp.green{background:#1fe36d}
  .lamp.yellow{background:#ffd34d}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .sub{color:#cfcfcf;font-size:14px;margin-top:4px}
  details{background:#151515;border-radius:12px;padding:8px 10px}
  details summary{cursor:pointer}
  .kv{display:grid;grid-template-columns:170px 1fr 70px;gap:8px;align-items:center;margin-top:8px}
  .kv label{color:#bbb;font-size:13px}
  .kv input[type=range]{width:100%}
  .hint{color:#bbb;font-size:13px;line-height:1.45}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:10px}
  @media (max-width:920px){.grid{grid-template-columns:1fr}}
  .smallinp{width:90px;padding:6px 8px;border-radius:8px;border:1px solid #333;background:#101010;color:#fff}
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart" class="btn">カメラ開始</button>
    <button id="btnStop" class="btn" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>
    <span class="chip"><input id="lockBack" type="checkbox" checked>背面固定</span>

    <label>解析(ms)</label>
    <input id="anMs" type="range" min="80" max="450" step="10" value="160">
    <span id="anMsVal" class="mono">160</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="last" selected>最後の1桁前（xxx.x）</option>
      <option value="none">なし</option>
    </select>

    <span class="chip"><input id="stabilize" type="checkbox" checked>ちらつき防止</span>
    <span class="chip"><input id="hold" type="checkbox" checked>確定値ホールド</span>
  </div>

  <details open>
    <summary>合わせ込み（横断窓ガイド＋角度）</summary>
    <div class="hint" style="margin-top:8px">
      体重計の表示が斜めなら <b>角度(°)</b> を調整して、黄色の窓がセグを<b>横断（垂直に刺さる）</b>ように合わせます。<br>
      角度は ROI 内だけに効きます（表示窓に合わせた後は固定推奨）。
    </div>
    <div class="kv"><label>角度（°）</label><input id="ang" type="range" min="-20" max="20" step="0.5" value="0"><span id="angv" class="mono">0.0</span></div>
    <div class="kv"><label>窓サイズ倍率</label><input id="winScale" type="range" min="0.60" max="1.60" step="0.05" value="1.00"><span id="winScaleVal" class="mono">1.00</span></div>

    <div class="kv"><label>ガイドX（%）</label><input id="gx" type="range" min="0" max="1" step="0.01"><span id="gxv"></span></div>
    <div class="kv"><label>ガイドY（%）</label><input id="gy" type="range" min="0" max="1" step="0.01"><span id="gyv"></span></div>
    <div class="kv"><label>ガイドW（%）</label><input id="gw" type="range" min="0.20" max="1" step="0.01"><span id="gwv"></span></div>
    <div class="kv"><label>ガイドH（%）</label><input id="gh" type="range" min="0.10" max="0.70" step="0.01"><span id="ghv"></span></div>

    <div class="row" style="margin-top:8px">
      <button id="btnGuideReset" class="btn" type="button">ガイド初期化</button>
      <span class="chip"><input id="showWindows" type="checkbox" checked>横断窓を表示</span>
      <span class="chip"><input id="showDigitBoxes" type="checkbox" checked>桁枠を表示</span>
    </div>
  </details>

  <details open>
    <summary>前処理（軽い・iPhone向け）</summary>
    <div class="row" style="margin-top:8px">
      <span class="chip"><input id="invert" type="checkbox">反転（白数字用）</span>
      <span class="chip"><input id="autoOtsu" type="checkbox" checked>自動2値化（Otsu）</span>
      <span class="chip">Otsuオフセット <input id="otsuOff" class="smallinp" type="number" step="1" value="-15"></span>
      <span class="chip"><input id="dilate" type="checkbox" checked>太らせる（細いセグ対策）</span>
      <span class="chip">太さ <input id="dilateN" class="smallinp" type="number" min="1" max="3" value="1"></span>
    </div>
    <div class="kv"><label>セグ判定しきい値（黒率）</label><input id="segThr" type="range" min="0.08" max="0.55" step="0.01" value="0.22"><span id="segThrVal"></span></div>
    <div class="kv"><label>空白判定（全体黒率）</label><input id="blankThr" type="range" min="0.00" max="0.10" step="0.005" value="0.02"><span id="blankThrVal"></span></div>
    <div class="hint" style="margin-top:8px">
      ・黒数字（明るい背景）なら <b>反転OFF</b> が基本（「黒が入ればON」）。<br>
      ・読めない時は、まず <b>セグ判定</b> を 0.16〜0.30 → 次に Otsuオフセット（-40〜+20）。<br>
    </div>
  </details>

  <details open>
    <summary>安定化（確定表示）</summary>
    <div class="kv"><label>確定に必要な連続フレーム</label><input id="needFrames" type="range" min="1" max="20" step="1" value="6"><span id="needFramesVal"></span></div>
    <div class="kv"><label>失敗許容（ms）</label><input id="graceMs" type="range" min="0" max="2500" step="50" value="900"><span id="graceMsVal"></span></div>
    <div class="row" style="margin-top:8px">
      <span class="chip">範囲 <input id="minVal" class="smallinp" type="number" step="0.1" value="10"> ～ <input id="maxVal" class="smallinp" type="number" step="0.1" value="250"></span>
      <span class="chip"><input id="force1dp" type="checkbox" checked>小数1桁に揃える</span>
    </div>
  </details>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>

    <div class="panel">
      <div><b>表示（確定）</b></div>
      <div class="big"><span id="lamp" class="lamp yellow"></span><span id="out">—</span></div>
      <div id="cand" class="sub mono">候補: —</div>
      <div id="dbg" class="hint mono" style="margin-top:8px"></div>
      <div class="row" style="margin-top:10px">
        <button id="btnCopy" class="btn" type="button">確定値をコピー</button>
      </div>
      <div class="hint" style="margin-top:8px">
        まず角度を合わせる → ROIを表示窓に合わせる → セグ判定しきい値を微調整、の順が一番速いです。
      </div>
    </div>
  </div>

  <canvas id="roi" style="display:none"></canvas>
  <canvas id="upr" style="display:none"></canvas>
</div>

<script>
const $=id=>document.getElementById(id);
const video=$("video"), overlay=$("overlay"), roi=$("roi"), upr=$("upr");
const ctxO=overlay.getContext("2d",{willReadFrequently:true});
const ctxR=roi.getContext("2d",{willReadFrequently:true});
const ctxU=upr.getContext("2d",{willReadFrequently:true});

const btnStart=$("btnStart"), btnStop=$("btnStop"), selCam=$("selCam"), lockBack=$("lockBack");
const anMs=$("anMs"), anMsVal=$("anMsVal"), digitsEl=$("digits"), decEl=$("decimal");
const stabilizeEl=$("stabilize"), holdEl=$("hold");
const ang=$("ang"), angv=$("angv"), winScale=$("winScale"), winScaleVal=$("winScaleVal");

const gx=$("gx"), gy=$("gy"), gw=$("gw"), gh=$("gh");
const gxv=$("gxv"), gyv=$("gyv"), gwv=$("gwv"), ghv=$("ghv");
const btnGuideReset=$("btnGuideReset"), showWindows=$("showWindows"), showDigitBoxes=$("showDigitBoxes");

const invertEl=$("invert"), autoOtsu=$("autoOtsu"), otsuOff=$("otsuOff"), dilate=$("dilate"), dilateN=$("dilateN");
const segThr=$("segThr"), segThrVal=$("segThrVal"), blankThr=$("blankThr"), blankThrVal=$("blankThrVal");

const needFrames=$("needFrames"), needFramesVal=$("needFramesVal"), graceMs=$("graceMs"), graceMsVal=$("graceMsVal");
const minVal=$("minVal"), maxVal=$("maxVal"), force1dp=$("force1dp");

const lamp=$("lamp"), out=$("out"), cand=$("cand"), dbg=$("dbg"), btnCopy=$("btnCopy");

let stream=null, rafId=null, lastAnalyzeAt=0;

const LS={
  cam:"sevenseg_cam_deviceid",
  lock:"sevenseg_lockback",
  guide:"sevenseg_guide_v20",
  an:"sevenseg_anms_v20",
  digits:"sevenseg_digits_v20",
  dec:"sevenseg_dec_v20",
  inv:"sevenseg_inv_v20",
  otsu:"sevenseg_otsu_v20",
  otsuOff:"sevenseg_otsuOff_v20",
  dil:"sevenseg_dil_v20",
  diln:"sevenseg_diln_v20",
  seg:"sevenseg_segthr_v20",
  blank:"sevenseg_blankthr_v20",
  nf:"sevenseg_needframes_v20",
  gm:"sevenseg_grace_v20",
  minv:"sevenseg_minv_v20",
  maxv:"sevenseg_maxv_v20",
  force:"sevenseg_force1dp_v20",
  showW:"sevenseg_showwin_v20",
  showB:"sevenseg_showbox_v20",
  stab:"sevenseg_stab_v20",
  hold:"sevenseg_hold_v20",
  ang:"sevenseg_ang_v20",
  ws:"sevenseg_winscale_v20",
};

function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function clamp01(v){return clamp(v,0,1)}
function setLamp(state){
  lamp.classList.remove("green","yellow");
  if(state==="green") lamp.classList.add("green");
  else lamp.classList.add("yellow");
}
function syncLabels(){
  anMsVal.textContent=String(anMs.value);
  segThrVal.textContent=Number(segThr.value).toFixed(2);
  blankThrVal.textContent=Number(blankThr.value).toFixed(3);
  needFramesVal.textContent=String(needFrames.value);
  graceMsVal.textContent=String(graceMs.value);

  angv.textContent=(+ang.value).toFixed(1);
  winScaleVal.textContent=(+winScale.value).toFixed(2);

  gxv.textContent=(+gx.value).toFixed(2);
  gyv.textContent=(+gy.value).toFixed(2);
  gwv.textContent=(+gw.value).toFixed(2);
  ghv.textContent=(+gh.value).toFixed(2);
}
function loadGuide(){
  const def={x:0.18,y:0.44,w:0.64,h:0.20};
  try{
    const s=localStorage.getItem(LS.guide);
    if(!s) return def;
    const o=JSON.parse(s);
    return {x:clamp01(+o.x),y:clamp01(+o.y),w:clamp(+o.w,0.20,1),h:clamp(+o.h,0.10,0.70)};
  }catch(_){return def}
}
let GUIDE=loadGuide();
function applyGuideToUI(){
  gx.value=GUIDE.x; gy.value=GUIDE.y; gw.value=GUIDE.w; gh.value=GUIDE.h;
  syncLabels();
}
function saveGuide(){ localStorage.setItem(LS.guide, JSON.stringify(GUIDE)); }

function restore(){
  lockBack.checked=(localStorage.getItem(LS.lock)??"1")==="1";
  anMs.value=(localStorage.getItem(LS.an)??"160");
  digitsEl.value=(localStorage.getItem(LS.digits)??"4");
  decEl.value=(localStorage.getItem(LS.dec)??"last");

  invertEl.checked=(localStorage.getItem(LS.inv)??"0")==="1";
  autoOtsu.checked=(localStorage.getItem(LS.otsu)??"1")==="1";
  otsuOff.value=(localStorage.getItem(LS.otsuOff)??"-15");
  dilate.checked=(localStorage.getItem(LS.dil)??"1")==="1";
  dilateN.value=(localStorage.getItem(LS.diln)??"1");
  segThr.value=(localStorage.getItem(LS.seg)??"0.22");
  blankThr.value=(localStorage.getItem(LS.blank)??"0.02");

  needFrames.value=(localStorage.getItem(LS.nf)??"6");
  graceMs.value=(localStorage.getItem(LS.gm)??"900");
  minVal.value=(localStorage.getItem(LS.minv)??"10");
  maxVal.value=(localStorage.getItem(LS.maxv)??"250");
  force1dp.checked=(localStorage.getItem(LS.force)??"1")==="1";

  showWindows.checked=(localStorage.getItem(LS.showW)??"1")==="1";
  showDigitBoxes.checked=(localStorage.getItem(LS.showB)??"1")==="1";
  stabilizeEl.checked=(localStorage.getItem(LS.stab)??"1")==="1";
  holdEl.checked=(localStorage.getItem(LS.hold)??"1")==="1";

  ang.value=(localStorage.getItem(LS.ang)??"0");
  winScale.value=(localStorage.getItem(LS.ws)??"1.00");

  GUIDE=loadGuide();
  applyGuideToUI();
}
restore();

function persist(){
  lockBack.onchange=()=>localStorage.setItem(LS.lock, lockBack.checked?"1":"0");
  anMs.oninput=()=>{localStorage.setItem(LS.an,anMs.value); syncLabels();}
  digitsEl.onchange=()=>localStorage.setItem(LS.digits, digitsEl.value);
  decEl.onchange=()=>localStorage.setItem(LS.dec, decEl.value);

  invertEl.onchange=()=>localStorage.setItem(LS.inv, invertEl.checked?"1":"0");
  autoOtsu.onchange=()=>localStorage.setItem(LS.otsu, autoOtsu.checked?"1":"0");
  otsuOff.onchange=()=>localStorage.setItem(LS.otsuOff, otsuOff.value);
  dilate.onchange=()=>localStorage.setItem(LS.dil, dilate.checked?"1":"0");
  dilateN.onchange=()=>localStorage.setItem(LS.diln, dilateN.value);
  segThr.oninput=()=>{localStorage.setItem(LS.seg, segThr.value); syncLabels();}
  blankThr.oninput=()=>{localStorage.setItem(LS.blank, blankThr.value); syncLabels();}

  needFrames.oninput=()=>{localStorage.setItem(LS.nf, needFrames.value); syncLabels();}
  graceMs.oninput=()=>{localStorage.setItem(LS.gm, graceMs.value); syncLabels();}
  minVal.onchange=()=>localStorage.setItem(LS.minv, minVal.value);
  maxVal.onchange=()=>localStorage.setItem(LS.maxv, maxVal.value);
  force1dp.onchange=()=>localStorage.setItem(LS.force, force1dp.checked?"1":"0");

  showWindows.onchange=()=>localStorage.setItem(LS.showW, showWindows.checked?"1":"0");
  showDigitBoxes.onchange=()=>localStorage.setItem(LS.showB, showDigitBoxes.checked?"1":"0");
  stabilizeEl.onchange=()=>localStorage.setItem(LS.stab, stabilizeEl.checked?"1":"0");
  holdEl.onchange=()=>localStorage.setItem(LS.hold, holdEl.checked?"1":"0");

  ang.oninput=()=>{localStorage.setItem(LS.ang, ang.value); syncLabels();}
  winScale.oninput=()=>{localStorage.setItem(LS.ws, winScale.value); syncLabels();}

  const bindGuide=(el,key)=>{
    el.addEventListener("input", ()=>{
      GUIDE[key]=parseFloat(el.value);
      if(key==="w") GUIDE.w=clamp(GUIDE.w,0.20,1);
      if(key==="h") GUIDE.h=clamp(GUIDE.h,0.10,0.70);
      GUIDE.x=clamp01(Math.min(GUIDE.x, 1-GUIDE.w));
      GUIDE.y=clamp01(Math.min(GUIDE.y, 1-GUIDE.h));
      saveGuide(); syncLabels();
    });
  };
  bindGuide(gx,"x"); bindGuide(gy,"y"); bindGuide(gw,"w"); bindGuide(gh,"h");
}
persist();

btnGuideReset.onclick=()=>{
  GUIDE={x:0.18,y:0.44,w:0.64,h:0.20};
  saveGuide();
  applyGuideToUI();
};

function isBackLabel(label){ return /(back|rear|environment|背面|リア|後ろ)/i.test(label||""); }

async function listCams({preserve=true,autoPickBack=true}={}){
  const prev=preserve?selCam.value:"";
  const saved=localStorage.getItem(LS.cam)||"";
  const devices=await navigator.mediaDevices.enumerateDevices();
  const cams=devices.filter(d=>d.kind==="videoinput");
  selCam.innerHTML="";
  cams.forEach((c,i)=>{
    const opt=document.createElement("option");
    opt.value=c.deviceId;
    opt.textContent=c.label||`Camera ${i+1}`;
    selCam.appendChild(opt);
  });
  if([...selCam.options].some(o=>o.value===prev)){ selCam.value=prev; return;}
  if([...selCam.options].some(o=>o.value===saved)){ selCam.value=saved; return;}
  if(autoPickBack && lockBack.checked){
    const back=[...selCam.options].find(o=>isBackLabel(o.textContent));
    if(back){ selCam.value=back.value; return; }
  }
  if(selCam.options.length) selCam.selectedIndex=0;
}
selCam.onchange=()=>localStorage.setItem(LS.cam, selCam.value||"");

async function startCamera(){
  await listCams({preserve:true,autoPickBack:false});
  try{
    const tmp=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:lockBack.checked?"environment":"user"}},audio:false});
    tmp.getTracks().forEach(t=>t.stop());
  }catch(e){}
  await listCams({preserve:true,autoPickBack:true});

  const deviceId=selCam.value||undefined;
  stream=await navigator.mediaDevices.getUserMedia({
    video:{
      deviceId: deviceId?{exact:deviceId}:undefined,
      facingMode: deviceId?undefined:{ideal:lockBack.checked?"environment":"user"},
      width:{ideal:1280}, height:{ideal:720}
    },
    audio:false
  });
  video.srcObject=stream;
  await video.play();

  btnStart.disabled=true;
  btnStop.disabled=false;

  overlay.width=video.videoWidth;
  overlay.height=video.videoHeight;

  resetStabilizer();
  loop();
}
function stopCamera(){
  cancelAnimationFrame(rafId); rafId=null;
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  video.pause(); video.srcObject=null;

  btnStart.disabled=false;
  btnStop.disabled=true;

  out.textContent="—";
  cand.textContent="候補: —";
  dbg.textContent="";
  setLamp("yellow");
}
btnStart.onclick=async()=>{ try{ await startCamera(); }catch(e){ alert("カメラ開始失敗: "+(e?.message||e)); } };
btnStop.onclick=()=>stopCamera();
selCam.onchange=async()=>{
  localStorage.setItem(LS.cam, selCam.value||"");
  if(!stream) return;
  stopCamera();
  await new Promise(r=>setTimeout(r,200));
  btnStart.onclick();
};

btnCopy.onclick=async()=>{
  const t=stableText||out.textContent;
  if(!t||t==="—") return;
  try{ await navigator.clipboard.writeText(t); }
  catch(_){ prompt("コピーして使ってください:", t); }
};

// ====== 7セグ辞書（a b c d e f g） ======
// ※ 7 は機種によって f(左上) も点く事があるので両方許可
const DIGIT_MAP = new Map([
  ["1111110","0"],
  ["0110000","1"],
  ["1101101","2"],
  ["1111001","3"],
  ["0110011","4"],
  ["1011011","5"],
  ["1011111","6"],
  ["1110000","7"], // a b c
  ["1110010","7"], // a b c f（あなたの指摘パターン）
  ["1111111","8"],
  ["1111011","9"],
]);

function clampInt(v,a,b){ v=v|0; return Math.max(a,Math.min(b,v)); }

// ====== Otsu ======
function otsuThreshold(gray){
  const hist = new Uint32Array(256);
  for(let i=0;i<gray.length;i++){
    const v = clampInt(gray[i],0,255);
    hist[v]++;
  }
  const total = gray.length;
  let sum=0;
  for(let i=0;i<256;i++) sum += i*hist[i];

  let sumB=0, wB=0, wF=0;
  let varMax=0, thr=128;
  for(let t=0;t<256;t++){
    wB += hist[t];
    if(wB===0) continue;
    wF = total - wB;
    if(wF===0) break;
    sumB += t*hist[t];
    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;
    const vb = wB*wF*(mB-mF)*(mB-mF);
    if(vb > varMax){ varMax = vb; thr = t; }
  }
  return thr;
}

function binarize(imageData, w, h){
  const d=imageData.data;
  const g=new Uint8Array(w*h);
  for(let i=0,p=0;i<g.length;i++,p+=4){
    const r=d[p], gg=d[p+1], b=d[p+2];
    g[i] = (0.299*r + 0.587*gg + 0.114*b) | 0;
  }

  let thr=128;
  if(autoOtsu.checked){
    thr = otsuThreshold(g);
    thr = clampInt(thr + (parseInt(otsuOff.value||"0",10)||0), 0, 255);
  }else{
    thr = clampInt(parseInt(otsuOff.value||"128",10)||128, 0, 255);
  }

  const bin=new Uint8Array(w*h);
  const inv=invertEl.checked;
  for(let i=0;i<g.length;i++){
    let v = (g[i] < thr) ? 1 : 0; // dark=ink
    if(inv) v = 1 - v;
    bin[i]=v;
  }

  if(dilate.checked){
    const n=clampInt(parseInt(dilateN.value||"1",10),1,3);
    for(let it=0;it<n;it++){
      const src=bin.slice();
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          const i=y*w+x;
          if(src[i]) continue;
          if(src[i-1]||src[i+1]||src[i-w]||src[i+w]||src[i-w-1]||src[i-w+1]||src[i+w-1]||src[i+w+1]){
            bin[i]=1;
          }
        }
      }
    }
  }

  return {bin, thr};
}

function blackRatio(bin, w, x0,y0,x1,y1){
  x0=clampInt(Math.floor(x0),0,w-1);
  x1=clampInt(Math.floor(x1),0,w);
  y0=Math.max(0,Math.floor(y0));
  y1=Math.max(0,Math.floor(y1));
  if(x1<=x0||y1<=y0) return 0;
  let sum=0, cnt=0;
  for(let y=y0;y<y1;y++){
    const row=y*w;
    for(let x=x0;x<x1;x++){
      sum += bin[row+x];
      cnt++;
    }
  }
  return cnt? (sum/cnt) : 0;
}

function guideRect(){
  const w=overlay.width, h=overlay.height;
  const x=Math.floor(GUIDE.x*w);
  const y=Math.floor(GUIDE.y*h);
  const ww=Math.floor(GUIDE.w*w);
  const hh=Math.floor(GUIDE.h*h);
  return {x,y,w:ww,h:hh};
}

// ====== 横断窓（upright基準・a b c d e f g） ======
function segCrossWindowsForDigit(dx,dy,dw,dh, scale){
  // セグ中心位置（upright想定）
  const C={
    a:{cx:dx+dw*0.50, cy:dy+dh*0.16, ori:"h"},
    g:{cx:dx+dw*0.50, cy:dy+dh*0.50, ori:"h"},
    d:{cx:dx+dw*0.50, cy:dy+dh*0.84, ori:"h"},
    f:{cx:dx+dw*0.25, cy:dy+dh*0.32, ori:"v"},
    b:{cx:dx+dw*0.75, cy:dy+dh*0.32, ori:"v"},
    e:{cx:dx+dw*0.25, cy:dy+dh*0.68, ori:"v"},
    c:{cx:dx+dw*0.75, cy:dy+dh*0.68, ori:"v"},
  };
  // 横断窓サイズ（ori=h:水平セグ→縦長窓, ori=v:垂直セグ→横長窓）
  const baseH = {w: dw*0.12, h: dh*0.24}; // 縦長（a,g,d）
  const baseV = {w: dw*0.24, h: dh*0.12}; // 横長（b,c,e,f）
  const out={};
  for(const k of ["a","b","c","d","e","f","g"]){
    const cc=C[k];
    const bsz = (cc.ori==="h")? baseH : baseV;
    const ww = bsz.w * scale;
    const hh = bsz.h * scale;
    let x = cc.cx - ww/2, y = cc.cy - hh/2;
    x = clamp(x, dx, dx+dw-ww);
    y = clamp(y, dy, dy+dh-hh);
    out[k]={x,y,w:ww,h:hh};
  }
  return out;
}

function toCandidateString(s){
  if(decEl.value==="last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
  }
  if(force1dp.checked && s && !s.includes(".")) s = s + ".0";
  return s;
}

function passesGate(text){
  if(!text) return false;
  const v=parseFloat(text);
  if(Number.isNaN(v)) return false;
  const mn=parseFloat(minVal.value||"0"), mx=parseFloat(maxVal.value||"9999");
  return v>=mn && v<=mx;
}

// --- 角度変換（ROI→upright / upright→ROI） ---
function deg2rad(d){ return d*Math.PI/180; }

function fitScaleForRotation(w,h,theta){
  const c=Math.abs(Math.cos(theta)), s=Math.abs(Math.sin(theta));
  const boundW = w*c + h*s;
  const boundH = w*s + h*c;
  return Math.min(w / boundW, h / boundH);
}

function drawRoiToUpright(r){
  roi.width=r.w; roi.height=r.h;
  ctxR.setTransform(1,0,0,1,0,0);
  ctxR.drawImage(video, r.x, r.y, r.w, r.h, 0,0,r.w,r.h);

  upr.width=r.w; upr.height=r.h;
  const theta = deg2rad(parseFloat(ang.value));
  const scale = fitScaleForRotation(r.w, r.h, theta); // clip防止
  ctxU.setTransform(1,0,0,1,0,0);
  ctxU.clearRect(0,0,r.w,r.h);
  ctxU.translate(r.w/2, r.h/2);
  ctxU.rotate(-theta);
  ctxU.scale(scale, scale);
  ctxU.drawImage(roi, -r.w/2, -r.h/2);
  ctxU.setTransform(1,0,0,1,0,0);
  return {theta, scale};
}

function mapUtoO(xu,yu, w,h, theta, scale){
  const cx=w/2, cy=h/2;
  let x = xu - cx, y = yu - cy;
  const ct=Math.cos(theta), st=Math.sin(theta);
  const xr = (ct*x - st*y) / scale;
  const yr = (st*x + ct*y) / scale;
  return {x: xr + cx, y: yr + cy};
}

function recognize(){
  const r=guideRect();
  const meta = drawRoiToUpright(r);

  const img=ctxU.getImageData(0,0,r.w,r.h);
  const {bin, thr}=binarize(img, r.w, r.h);

  const nDigits=parseInt(digitsEl.value,10);
  const step=r.w / nDigits;

  const segT=parseFloat(segThr.value);
  const blankT=parseFloat(blankThr.value);
  const wScale=parseFloat(winScale.value);

  let outStr="";
  const perDigitDbg=[];
  for(let i=0;i<nDigits;i++){
    const dx=i*step, dw=step, dy=0, dh=r.h;

    const inkAll = blackRatio(bin, r.w, dx, dy, dx+dw, dy+dh);
    if(inkAll < blankT){
      perDigitDbg.push(`#${i+1}: blank ink=${inkAll.toFixed(2)}`);
      outStr += "?";
      continue;
    }

    const w7=segCrossWindowsForDigit(dx,dy,dw,dh,wScale);
    const bits=[];
    const inks={};
    for(const key of ["a","b","c","d","e","f","g"]){
      const ww=w7[key];
      const ink=blackRatio(bin, r.w, ww.x, ww.y, ww.x+ww.w, ww.y+ww.h);
      inks[key]=ink;
      bits.push(ink >= segT ? "1":"0");
    }
    const pat=bits.join("");
    const digit = DIGIT_MAP.get(pat) ?? "?";
    outStr += digit;
    perDigitDbg.push(`#${i+1}: ${digit} pat=${pat} all=${inkAll.toFixed(2)} a=${inks.a.toFixed(2)} b=${inks.b.toFixed(2)} c=${inks.c.toFixed(2)} d=${inks.d.toFixed(2)} e=${inks.e.toFixed(2)} f=${inks.f.toFixed(2)} g=${inks.g.toFixed(2)}`);
  }

  const raw = outStr.replace(/\?/g,"");
  const candText = (/^[0-9?]+$/.test(outStr) && raw.length>0) ? toCandidateString(outStr) : null;

  let conf=0;
  if(outStr && outStr.length){
    const okc=[...outStr].filter(ch=>ch!=="?").length;
    conf = okc / outStr.length;
  }

  return {text:candText, conf, thr, debug:perDigitDbg.join(" | "), meta};
}

// ====== 安定化 ======
let lastCand=null, consec=0, stableText=null, lastOkAt=0;
function resetStabilizer(){ lastCand=null; consec=0; stableText=null; lastOkAt=0; setLamp("yellow"); }

function applyCandidate(candidate, conf, thr, debug, meta){
  cand.textContent = `候補: ${candidate ?? "—"} (conf=${conf.toFixed(2)} thr=${thr})`;
  const need=parseInt(needFrames.value,10);
  const grace=parseInt(graceMs.value,10);

  const acceptable = (candidate !== null) && (conf >= 0.75) && passesGate(candidate);

  if(acceptable){
    lastOkAt=performance.now();
    if(candidate===lastCand) consec++;
    else { lastCand=candidate; consec=1; }

    if(!stabilizeEl.checked){
      stableText=candidate; out.textContent=stableText; setLamp("green");
    }else{
      if(consec>=need){
        stableText=candidate; out.textContent=stableText; setLamp("green");
      }else{
        if(!holdEl.checked) out.textContent="—";
        else if(stableText) out.textContent=stableText;
        setLamp("yellow");
      }
    }
  }else{
    lastCand=null; consec=0;
    const now=performance.now();
    const withinGrace = stableText && (now - lastOkAt) <= grace;
    if(withinGrace && holdEl.checked){
      out.textContent=stableText;
      setLamp("green");
    }else{
      if(!holdEl.checked) out.textContent="—";
      else if(stableText) out.textContent=stableText;
      setLamp("yellow");
    }
  }

  const camLabel = selCam.selectedOptions?.[0]?.textContent || "";
  dbg.textContent =
    `mode=7cross+angle | ang=${(+ang.value).toFixed(1)}deg fitScale=${meta.scale.toFixed(3)} `+
    `digits=${digitsEl.value} inv=${invertEl.checked?1:0} otsu=${autoOtsu.checked?1:0} off=${otsuOff.value} `+
    `dil=${dilate.checked?1:0} n=${dilateN.value} winScale=${(+winScale.value).toFixed(2)} segThr=${Number(segThr.value).toFixed(2)} blankThr=${Number(blankThr.value).toFixed(3)} | `+
    `stable=${stabilizeEl.checked?1:0} consec=${consec}/${need} grace=${grace}ms | cam="${camLabel}"\n`+
    debug;
}

function drawPoly(pts, fill, stroke){
  ctxO.beginPath();
  ctxO.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctxO.lineTo(pts[i].x, pts[i].y);
  ctxO.closePath();
  if(fill){ ctxO.fillStyle=fill; ctxO.fill(); }
  if(stroke){ ctxO.strokeStyle=stroke; ctxO.stroke(); }
}

function drawOverlay(meta){
  ctxO.clearRect(0,0,overlay.width,overlay.height);
  const r=guideRect();

  ctxO.strokeStyle="rgba(255,0,0,.95)";
  ctxO.lineWidth=3;
  ctxO.strokeRect(r.x+1,r.y+1,r.w-2,r.h-2);

  const nDigits=parseInt(digitsEl.value,10);
  const step=r.w/nDigits;

  if(showDigitBoxes.checked){
    ctxO.strokeStyle="rgba(255,0,0,.55)";
    ctxO.lineWidth=2;
    for(let i=1;i<nDigits;i++){
      const xu = i*step;
      const p1 = mapUtoO(xu, 0, r.w, r.h, meta.theta, meta.scale);
      const p2 = mapUtoO(xu, r.h, r.w, r.h, meta.theta, meta.scale);
      ctxO.beginPath();
      ctxO.moveTo(r.x+p1.x, r.y+p1.y);
      ctxO.lineTo(r.x+p2.x, r.y+p2.y);
      ctxO.stroke();
    }
  }

  if(showWindows.checked){
    ctxO.lineWidth=1;
    const wScale=parseFloat(winScale.value);
    for(let i=0;i<nDigits;i++){
      const dx=i*step, dw=step, dy=0, dh=r.h;
      const w7=segCrossWindowsForDigit(dx,dy,dw,dh,wScale);
      for(const k of ["a","b","c","d","e","f","g"]){
        const w=w7[k];
        const corners=[
          {x:w.x,     y:w.y},
          {x:w.x+w.w, y:w.y},
          {x:w.x+w.w, y:w.y+w.h},
          {x:w.x,     y:w.y+w.h},
        ].map(p=>{
          const q=mapUtoO(p.x,p.y,r.w,r.h, meta.theta, meta.scale);
          return {x:r.x+q.x, y:r.y+q.y};
        });
        drawPoly(corners, "rgba(255,255,0,.22)", "rgba(255,255,0,.55)");
      }
    }
  }
}

function loop(){
  if(!stream){ rafId=requestAnimationFrame(loop); return; }
  const now=performance.now();
  const interval=parseInt(anMs.value,10);

  if(now-lastAnalyzeAt >= interval){
    lastAnalyzeAt=now;
    const res=recognize();
    drawOverlay(res.meta);
    applyCandidate(res.text, res.conf, res.thr, res.debug, res.meta);
  }else{
    // 解析の合間もガイドだけ更新
    const r=guideRect();
    const theta=deg2rad(parseFloat(ang.value));
    const scale=fitScaleForRotation(r.w,r.h,theta);
    drawOverlay({theta,scale});
  }
  rafId=requestAnimationFrame(loop);
}

navigator.mediaDevices?.addEventListener?.('devicechange', ()=>listCams({preserve:true,autoPickBack:true}));
listCams({preserve:true,autoPickBack:true}).catch(()=>{});
syncLabels();
</script>
</body>
</html>
