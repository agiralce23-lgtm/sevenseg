<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ認識 Webアプリ v16（TFJS学習モデル / 自動桁分割）</title>
<style>
  body{font-family:system-ui,-apple-system,sans-serif;margin:0;background:#111;color:#eee}
  .wrap{display:flex;flex-direction:column;gap:10px;padding:10px;max-width:1200px;margin:0 auto}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button,select,input{font-size:16px;padding:8px 10px}
  .stage{position:relative;width:100%;aspect-ratio:16/9;background:#000;overflow:hidden;border-radius:10px}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  .roi{position:absolute;border:2px solid rgba(255,0,0,.9);box-shadow:0 0 0 9999px rgba(0,0,0,.35);border-radius:8px;pointer-events:none}
  .panel{background:#1b1b1b;padding:10px;border-radius:10px}
  .k{color:#9ad}
  .big{font-size:36px;font-weight:900;letter-spacing:.5px;display:flex;align-items:center;gap:10px}
  .sub{font-size:14px;color:#cfcfcf;margin-top:4px}
  .hint{color:#bbb;font-size:13px;line-height:1.45}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:10px}
  @media (max-width:920px){.grid{grid-template-columns:1fr}}
  .chip{display:flex;align-items:center;gap:6px;background:#222;padding:6px 8px;border-radius:999px}
  details{background:#151515;border-radius:10px;padding:8px 10px}
  details summary{cursor:pointer}
  .kv{display:grid;grid-template-columns:180px 1fr 70px;gap:8px;align-items:center;margin-top:8px}
  .kv label{color:#bbb;font-size:13px}
  .kv input[type=range]{width:100%}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .lamp{width:12px;height:12px;border-radius:999px;background:#555;box-shadow:0 0 0 2px rgba(255,255,255,.08) inset}
  .lamp.green{background:#1fe36d}
  .lamp.yellow{background:#ffd34d}
  .btn{background:#2a2a2a;border:1px solid #3a3a3a;color:#fff;border-radius:10px}
  .btn:active{transform:translateY(1px)}
  .smallinp{width:90px;padding:6px 8px;border-radius:8px;border:1px solid #333;background:#101010;color:#fff}
  .digits{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .digcard{background:#121212;border:1px solid #2b2b2b;border-radius:10px;padding:8px}
  .digcard canvas{display:block;width:72px;height:72px;border-radius:8px;background:#000}
  .digmeta{margin-top:6px;font-size:12px;color:#cfcfcf}
</style>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.20.0/dist/tf-backend-wasm.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart" class="btn">カメラ開始</button>
    <button id="btnStop" class="btn" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>
    <span class="chip"><input id="lockBack" type="checkbox" checked>背面固定</span>

    <span class="chip"><input id="useML" type="checkbox" checked>学習モデル使用</span>
    <span class="chip"><input id="useSeg" type="checkbox" checked>構造認識(7窓)</span>
    <button id="btnLoadModel" class="btn" type="button">モデル読込</button>

    <label>推論間隔(ms)</label>
    <input id="anMs" type="range" min="80" max="400" step="10" value="160">
    <span id="anMsVal" class="mono">160</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="last" selected>最後の1桁前（xxx.x）</option>
      <option value="none">なし</option>
    </select>

    <span class="chip"><input id="stabilize" type="checkbox" checked>ちらつき防止</span>
    <span class="chip"><input id="hold" type="checkbox" checked>確定値ホールド</span>
    <span class="chip"><input id="wasm" type="checkbox" checked>TFJS WASM（iPhone安定）</span>
  </div>

  <details open>
    <summary>自動桁分割（ここがズレると conf が 0.09〜0.10 で「全部8」になります）</summary>
    <div class="row" style="margin-top:8px">
      <span class="chip"><input id="autoSplit" type="checkbox" checked>自動桁分割</span>
      <span class="chip">検出縮小W <input id="splitW" class="smallinp" type="number" value="320"></span>
      <span class="chip">列しきい値(%) <input id="colPct" class="smallinp" type="number" step="0.5" value="6.0"></span>
      <span class="chip">最小幅(px) <input id="minRun" class="smallinp" type="number" value="10"></span>
      <span class="chip">結合距離(px) <input id="mergeGap" class="smallinp" type="number" value="6"></span>
    </div>
    <div class="hint" style="margin-top:8px">
      ・kg の文字や枠が入っても、数字の柱（縦投影）で桁領域を見つけます。<br>
      ・うまく分割できない場合は「列しきい値(%)」を 4〜10 の範囲で動かしてください。
    </div>
  </details>


  <details>
    <summary>構造認識（7窓: セグメント横断でON/OFF判定）</summary>
    <div class="row" style="margin-top:8px;flex-wrap:wrap">
      <span class="chip"><input id="segBold" type="checkbox" checked>太らせる（細線対策）</span>
      <span class="chip">MLフォールバックconf <input id="segFallback" class="smallinp" type="number" step="0.05" value="0.55"></span>
      <span class="chip">空白判定(ink%) <input id="segBlankInk" class="smallinp" type="number" step="0.01" value="0.02"></span>
    </div>
    <div class="hint" style="margin-top:8px">
      ・各桁を7つの小領域（a〜g）に分け、各領域の「黒(=セグ)ピクセル比」でON/OFFを決めます。<br>
      ・領域はセグメントを<strong>横断する</strong>形に置くと、周囲の枠や文字の影響が減ります（PDFの図6の考え方）。<br>
      ・まずは「構造認識(7窓)ON + 自動2値化(Otsu)」で安定させ、難しい時だけ学習モデルをONにしてください。
    </div>
  </details>

  <details open>
    <summary>入力前処理（まずは raw 推奨）</summary>
    <div class="row" style="margin-top:8px">
      <label>入力モード</label>
      <select id="preMode">
        <option value="raw" selected>raw（そのままグレースケール）</option>
        <option value="invert">invert（白黒反転）</option>
        <option value="otsu">otsu（二値化:自動しきい値）</option>
        <option value="otsu_inv">otsu+invert（二値化して反転）</option>
      </select>
      <span class="chip"><input id="autoInv" type="checkbox">自動反転（平均で判定）</span>
      <span class="chip">γ <input id="gamma" class="smallinp" type="number" step="0.1" value="1.0"></span>
      <span class="chip">コントラスト <input id="contrast" class="smallinp" type="number" step="0.1" value="1.2"></span>
      <span class="chip"><input id="norm01" type="checkbox" checked>0..1正規化</span>
    </div>

    <div class="kv"><label>上下マージン（%）</label><input id="my" type="range" min="0" max="40" step="1" value="8"><span id="myv"></span></div>

    <div class="hint" style="margin-top:8px">
      あなたの学習スクリプト（CNN）は基本「グレースケール」学習なので、まず raw で合わせるのが近道です。
    </div>
  </details>

  <details open>
    <summary>安定化（確定表示）</summary>
    <div class="kv"><label>確定に必要な連続フレーム</label><input id="needFrames" type="range" min="1" max="20" step="1" value="6"><span id="needFramesVal"></span></div>
    <div class="kv"><label>確定に必要な信頼度</label><input id="needConf" type="range" min="0.20" max="0.99" step="0.01" value="0.55"><span id="needConfVal"></span></div>
    <div class="kv"><label>失敗許容（ms）</label><input id="graceMs" type="range" min="0" max="2500" step="50" value="900"><span id="graceMsVal"></span></div>
    <div class="row" style="margin-top:8px">
      <span class="chip">範囲 <input id="minVal" class="smallinp" type="number" step="0.1" value="10"> ～ <input id="maxVal" class="smallinp" type="number" step="0.1" value="250"></span>
      <span class="chip"><input id="force1dp" type="checkbox" checked>小数1桁に揃える</span>
    </div>
  </details>

  <details>
    <summary>ROI調整（1回合わせたら保存）</summary>
    <div class="kv"><label>X</label><input id="roiX" type="range" min="0" max="1" step="0.01"><span id="roiXv"></span></div>
    <div class="kv"><label>Y</label><input id="roiY" type="range" min="0" max="1" step="0.01"><span id="roiYv"></span></div>
    <div class="kv"><label>W</label><input id="roiW" type="range" min="0.05" max="1" step="0.01"><span id="roiWv"></span></div>
    <div class="kv"><label>H</label><input id="roiH" type="range" min="0.05" max="1" step="0.01"><span id="roiHv"></span></div>
    <div class="row" style="margin-top:8px">
      <button id="btnRoiReset" type="button" class="btn">ROIリセット</button>
    </div>
    <div class="hint" style="margin-top:6px">
      ROIは「表示窓だけ」に。周囲の印字が入るほど誤判定が増えます。
    </div>
  </details>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div id="roi" class="roi"></div>
    </div>

    <div class="panel">
      <div><span class="k">表示（確定）</span></div>
      <div class="big"><span id="lamp" class="lamp"></span><span id="out">—</span></div>
      <div id="candLine" class="sub mono">候補: —</div>
      <div class="hint mono" id="dbg"></div>
      <div class="row" style="margin-top:10px">
        <button id="btnCopy" class="btn" type="button">確定値をコピー</button>
      </div>
      <div class="hint mono" id="mlState" style="margin-top:6px">ml: not loaded</div>

      <div class="digits" id="digPrev"></div>

      <hr style="border:0;border-top:1px solid #333;margin:10px 0">
      <div class="hint">
        ・conf が 0.09〜0.10 なら「モデルが桁を見失ってる」状態です（自動桁分割とROIで直ります）。<br>
      </div>
    </div>
  </div>

  <canvas id="work" style="display:none"></canvas>
  <canvas id="seg" style="display:none"></canvas>
  <canvas id="dig" style="display:none"></canvas>
</div>

<script>
const $ = (id)=>document.getElementById(id);

const video=$("video"), overlay=$("overlay"), work=$("work"), seg=$("seg"), dig=$("dig");
const ctxO = overlay.getContext('2d',{willReadFrequently:true});
const ctxW = work.getContext('2d',{willReadFrequently:true});
const ctxS = seg.getContext('2d',{willReadFrequently:true});
const ctxD = dig.getContext('2d',{willReadFrequently:true});

const btnStart=$("btnStart"), btnStop=$("btnStop"), selCam=$("selCam");
const lockBack=$("lockBack");
const useMLEl=$("useML"), useSegEl=$("useSeg"), btnLoadModel=$("btnLoadModel");
const segBoldEl=$("segBold"), segFallbackEl=$("segFallback"), segBlankInkEl=$("segBlankInk");
const anMsEl=$("anMs"), anMsVal=$("anMsVal");
const digitsEl=$("digits"), decEl=$("decimal");
const stabilizeEl=$("stabilize"), holdEl=$("hold");
const needFramesEl=$("needFrames"), needFramesVal=$("needFramesVal");
const needConfEl=$("needConf"), needConfVal=$("needConfVal");
const graceMsEl=$("graceMs"), graceMsVal=$("graceMsVal");
const minValEl=$("minVal"), maxValEl=$("maxVal"), force1dpEl=$("force1dp");
const wasmEl=$("wasm");

const autoSplitEl=$("autoSplit"), splitWEl=$("splitW"), colPctEl=$("colPct"), minRunEl=$("minRun"), mergeGapEl=$("mergeGap");

const preModeEl=$("preMode"), autoInvEl=$("autoInv"), norm01El=$("norm01");
const gammaEl=$("gamma"), contrastEl=$("contrast"), myEl=$("my"), myv=$("myv");

const outEl=$("out"), candLine=$("candLine"), dbgEl=$("dbg"), roiEl=$("roi"), lampEl=$("lamp"), btnCopy=$("btnCopy");
const mlStateEl=$("mlState"), digPrev=$("digPrev");
const roiX=$("roiX"), roiY=$("roiY"), roiW=$("roiW"), roiH=$("roiH");
const roiXv=$("roiXv"), roiYv=$("roiYv"), roiWv=$("roiWv"), roiHv=$("roiHv");
const btnRoiReset=$("btnRoiReset");

let stream=null, rafId=null;
let inflight=false;

const LS={
  cam:"sevenseg_cam_deviceid", lock:"sevenseg_lockback", roi:"sevenseg_roi_v16",
  useML:"sevenseg_useml", useSeg:"sevenseg_useseg", segBold:"sevenseg_segbold", segFallback:"sevenseg_segfallback", segBlankInk:"sevenseg_segblankink", an:"sevenseg_anms", digits:"sevenseg_digits", dec:"sevenseg_dec",
  stab:"sevenseg_stab", hold:"sevenseg_hold", nf:"sevenseg_needframes", nc:"sevenseg_needconf", gm:"sevenseg_gracems",
  minv:"sevenseg_minval", maxv:"sevenseg_maxval", force:"sevenseg_force1dp", wasm:"sevenseg_wasm",
  model:"sevenseg_model_url",
  premode:"sevenseg_premode", autoinv:"sevenseg_autoinv", norm01:"sevenseg_norm01", gamma:"sevenseg_gamma", contrast:"sevenseg_contrast",
  my:"sevenseg_my",
  autos:"sevenseg_autosplit", splitw:"sevenseg_splitw", colpct:"sevenseg_colpct", minrun:"sevenseg_minrun", mergegap:"sevenseg_mergegap"
};

function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function clamp01(v){return clamp(v,0,1)}
function setLamp(state){
  lampEl.classList.remove("green","yellow");
  if(state==="green") lampEl.classList.add("green");
  if(state==="yellow") lampEl.classList.add("yellow");
}
function setRoiBox(){
  const stage=roiEl.parentElement;
  const r=stage.getBoundingClientRect();
  roiEl.style.left=(ROI.x*r.width)+"px";
  roiEl.style.top=(ROI.y*r.height)+"px";
  roiEl.style.width=(ROI.w*r.width)+"px";
  roiEl.style.height=(ROI.h*r.height)+"px";
}
window.addEventListener('resize', setRoiBox);

// ROI
const defaultRoi={x:0.18,y:0.44,w:0.64,h:0.20};
let ROI=loadROI();
function loadROI(){
  try{
    const s=localStorage.getItem(LS.roi); if(!s) return {...defaultRoi};
    const o=JSON.parse(s);
    return {x:clamp01(+o.x),y:clamp01(+o.y),w:clamp01(+o.w),h:clamp01(+o.h)};
  }catch(_){return {...defaultRoi}}
}
function saveROI(){localStorage.setItem(LS.roi,JSON.stringify(ROI))}

function syncLabels(){
  anMsVal.textContent=String(anMsEl.value);
  needFramesVal.textContent=String(needFramesEl.value);
  needConfVal.textContent=Number(needConfEl.value).toFixed(2);
  graceMsVal.textContent=String(graceMsEl.value);
  myv.textContent=myEl.value+"%";

  roiX.value=ROI.x; roiY.value=ROI.y; roiW.value=ROI.w; roiH.value=ROI.h;
  roiXv.textContent=ROI.x.toFixed(2);
  roiYv.textContent=ROI.y.toFixed(2);
  roiWv.textContent=ROI.w.toFixed(2);
  roiHv.textContent=ROI.h.toFixed(2);
}
function bindRoi(sl,key){
  sl.addEventListener('input', ()=>{
    ROI[key]=clamp01(parseFloat(sl.value));
    if(key==="w") ROI.w=Math.max(0.05,ROI.w);
    if(key==="h") ROI.h=Math.max(0.05,ROI.h);
    ROI.x=clamp01(Math.min(ROI.x,1-ROI.w));
    ROI.y=clamp01(Math.min(ROI.y,1-ROI.h));
    saveROI(); syncLabels(); setRoiBox();
  });
}
bindRoi(roiX,"x"); bindRoi(roiY,"y"); bindRoi(roiW,"w"); bindRoi(roiH,"h");
btnRoiReset.onclick=()=>{ ROI={...defaultRoi}; saveROI(); syncLabels(); setRoiBox(); };

// settings restore
function restore(){
  lockBack.checked=(localStorage.getItem(LS.lock)??"1")==="1";
  selCam.value=localStorage.getItem(LS.cam)||"";
  useMLEl.checked=(localStorage.getItem(LS.useML)??"1")==="1";
  useSegEl.checked=(localStorage.getItem(LS.useSeg)??"1")==="1";
  segBoldEl.checked=(localStorage.getItem(LS.segBold)??"1")==="1";
  segFallbackEl.value=(localStorage.getItem(LS.segFallback)??"0.55");
  segBlankInkEl.value=(localStorage.getItem(LS.segBlankInk)??"0.02");
  anMsEl.value=(localStorage.getItem(LS.an)??"160");
  digitsEl.value=(localStorage.getItem(LS.digits)??"4");
  decEl.value=(localStorage.getItem(LS.dec)??"last");

  stabilizeEl.checked=(localStorage.getItem(LS.stab)??"1")==="1";
  holdEl.checked=(localStorage.getItem(LS.hold)??"1")==="1";
  needFramesEl.value=(localStorage.getItem(LS.nf)??"6");
  needConfEl.value=(localStorage.getItem(LS.nc)??"0.55");
  graceMsEl.value=(localStorage.getItem(LS.gm)??"900");
  minValEl.value=(localStorage.getItem(LS.minv)??"10");
  maxValEl.value=(localStorage.getItem(LS.maxv)??"250");
  force1dpEl.checked=(localStorage.getItem(LS.force)??"1")==="1";
  wasmEl.checked=(localStorage.getItem(LS.wasm)??"1")==="1";

  preModeEl.value=(localStorage.getItem(LS.premode)??"raw");
  autoInvEl.checked=(localStorage.getItem(LS.autoinv)??"0")==="1";
  norm01El.checked=(localStorage.getItem(LS.norm01)??"1")==="1";
  gammaEl.value=(localStorage.getItem(LS.gamma)??"1.0");
  contrastEl.value=(localStorage.getItem(LS.contrast)??"1.2");
  myEl.value=(localStorage.getItem(LS.my)??"8");

  autoSplitEl.checked=(localStorage.getItem(LS.autos)??"1")==="1";
  splitWEl.value=(localStorage.getItem(LS.splitw)??"320");
  colPctEl.value=(localStorage.getItem(LS.colpct)??"6.0");
  minRunEl.value=(localStorage.getItem(LS.minrun)??"10");
  mergeGapEl.value=(localStorage.getItem(LS.mergegap)??"6");

  syncLabels();
}
restore();

function persist(){
  lockBack.onchange=()=>localStorage.setItem(LS.lock, lockBack.checked?"1":"0");
  useMLEl.onchange=()=>localStorage.setItem(LS.useML, useMLEl.checked?"1":"0");
  useSegEl.onchange=()=>localStorage.setItem(LS.useSeg, useSegEl.checked?"1":"0");
  segBoldEl.onchange=()=>localStorage.setItem(LS.segBold, segBoldEl.checked?"1":"0");
  segFallbackEl.onchange=()=>localStorage.setItem(LS.segFallback, segFallbackEl.value);
  segBlankInkEl.onchange=()=>localStorage.setItem(LS.segBlankInk, segBlankInkEl.value);
  anMsEl.oninput=()=>{localStorage.setItem(LS.an,anMsEl.value); syncLabels();}
  digitsEl.onchange=()=>{localStorage.setItem(LS.digits,digitsEl.value); buildDigitPreview();}
  decEl.onchange=()=>localStorage.setItem(LS.dec,decEl.value);
  stabilizeEl.onchange=()=>localStorage.setItem(LS.stab, stabilizeEl.checked?"1":"0");
  holdEl.onchange=()=>localStorage.setItem(LS.hold, holdEl.checked?"1":"0");
  needFramesEl.oninput=()=>{localStorage.setItem(LS.nf,needFramesEl.value); syncLabels();}
  needConfEl.oninput=()=>{localStorage.setItem(LS.nc,needConfEl.value); syncLabels();}
  graceMsEl.oninput=()=>{localStorage.setItem(LS.gm,graceMsEl.value); syncLabels();}
  minValEl.onchange=()=>localStorage.setItem(LS.minv,minValEl.value);
  maxValEl.onchange=()=>localStorage.setItem(LS.maxv,maxValEl.value);
  force1dpEl.onchange=()=>localStorage.setItem(LS.force, force1dpEl.checked?"1":"0");
  wasmEl.onchange=()=>localStorage.setItem(LS.wasm, wasmEl.checked?"1":"0");

  preModeEl.onchange=()=>localStorage.setItem(LS.premode, preModeEl.value);
  autoInvEl.onchange=()=>localStorage.setItem(LS.autoinv, autoInvEl.checked?"1":"0");
  norm01El.onchange=()=>localStorage.setItem(LS.norm01, norm01El.checked?"1":"0");
  gammaEl.onchange=()=>localStorage.setItem(LS.gamma, gammaEl.value);
  contrastEl.onchange=()=>localStorage.setItem(LS.contrast, contrastEl.value);
  myEl.oninput=()=>{localStorage.setItem(LS.my, myEl.value); syncLabels();}

  autoSplitEl.onchange=()=>localStorage.setItem(LS.autos, autoSplitEl.checked?"1":"0");
  splitWEl.onchange=()=>localStorage.setItem(LS.splitw, splitWEl.value);
  colPctEl.onchange=()=>localStorage.setItem(LS.colpct, colPctEl.value);
  minRunEl.onchange=()=>localStorage.setItem(LS.minrun, minRunEl.value);
  mergeGapEl.onchange=()=>localStorage.setItem(LS.mergegap, mergeGapEl.value);
}
persist();

// camera list
function isBackLabel(label){ return /(back|rear|environment|背面|リア|後ろ)/i.test(label||""); }
async function listCams({preserve=true,autoPickBack=true}={}){
  const prev=preserve?selCam.value:"";
  const saved=localStorage.getItem(LS.cam)||"";
  const devices=await navigator.mediaDevices.enumerateDevices();
  const cams=devices.filter(d=>d.kind==="videoinput");
  selCam.innerHTML="";
  cams.forEach((c,i)=>{
    const opt=document.createElement("option");
    opt.value=c.deviceId;
    opt.textContent=c.label||`Camera ${i+1}`;
    selCam.appendChild(opt);
  });
  if([...selCam.options].some(o=>o.value===prev)){ selCam.value=prev; return;}
  if([...selCam.options].some(o=>o.value===saved)){ selCam.value=saved; return;}
  if(autoPickBack && lockBack.checked){
    const back=[...selCam.options].find(o=>isBackLabel(o.textContent));
    if(back){ selCam.value=back.value; return; }
  }
  if(selCam.options.length) selCam.selectedIndex=0;
}
selCam.onchange=()=>localStorage.setItem(LS.cam, selCam.value||"");

// start/stop
async function startCamera(){
  await listCams({preserve:true,autoPickBack:false});
  try{
    const tmp=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:lockBack.checked?"environment":"user"}},audio:false});
    tmp.getTracks().forEach(t=>t.stop());
  }catch(e){}
  await listCams({preserve:true,autoPickBack:true});

  const deviceId=selCam.value||undefined;
  stream=await navigator.mediaDevices.getUserMedia({
    video:{
      deviceId: deviceId?{exact:deviceId}:undefined,
      facingMode: deviceId?undefined:{ideal:lockBack.checked?"environment":"user"},
      width:{ideal:1280}, height:{ideal:720}
    },
    audio:false
  });

  video.srcObject=stream;
  await video.play();

  btnStart.disabled=true;
  btnStop.disabled=false;

  overlay.width=video.videoWidth;
  overlay.height=video.videoHeight;

  setRoiBox();
  resetStabilizer();
  buildDigitPreview();
  loop();
}
function stopCamera(){
  cancelAnimationFrame(rafId); rafId=null;
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  video.pause(); video.srcObject=null;

  btnStart.disabled=false;
  btnStop.disabled=true;

  outEl.textContent="—";
  candLine.textContent="候補: —";
  dbgEl.textContent="";
  setLamp("yellow");
}
btnStart.onclick=async()=>{ try{ await startCamera(); }catch(e){ alert("カメラ開始失敗: "+(e?.message||e)); } };
btnStop.onclick=()=>stopCamera();
selCam.onchange=async()=>{
  localStorage.setItem(LS.cam, selCam.value||"");
  if(!stream) return;
  stopCamera();
  await new Promise(r=>setTimeout(r,200));
  btnStart.onclick();
};

// helpers
function toFixed1dp(text){
  if(!force1dpEl.checked || !text) return text;
  if(text.includes(".")) return text;
  return text + ".0";
}
function passesGate(text){
  if(!text) return false;
  const v=parseFloat(text);
  const minV=parseFloat(minValEl.value||"0"), maxV=parseFloat(maxValEl.value||"9999");
  if(Number.isNaN(v)) return false;
  if(v<minV || v>maxV) return false;
  return true;
}


// ===== 7窓（構造）認識 =====
// セグメント a,b,c,d,e,f,g の順で使う
const SEG_PATTERNS = [
  {ch:"0", bits:"1111110"},
  {ch:"1", bits:"0110000"},
  {ch:"2", bits:"1111101"},
  {ch:"3", bits:"1111001"},
  {ch:"4", bits:"0110011"},
  {ch:"5", bits:"1011011"},
  {ch:"6", bits:"1011111"},
  {ch:"7", bits:"1110000"},
  {ch:"8", bits:"1111111"},
  {ch:"9", bits:"1111011"},
  {ch:"-", bits:"0000001"},
  {ch:"",  bits:"0000000"} // blank
];

// raw(0..1) から「セグ(インク)」を 1 にしたマスクを作る（濃い側/明るい側の少ない方を digit とみなす）
function maskFromRaw(raw, W, H){
  const thr = otsuThreshold(raw); // 0..1
  let dark=0;
  const N=raw.length;
  for(let i=0;i<N;i++) if(raw[i]<thr) dark++;
  const bright = N - dark;
  const digitIsDark = dark < bright; // 少ない側=数字
  const m = new Uint8Array(N);
  if(digitIsDark){
    for(let i=0;i<N;i++) m[i] = (raw[i]<thr)?1:0;
  }else{
    for(let i=0;i<N;i++) m[i] = (raw[i]>=thr)?1:0;
  }
  return {mask:m, thr, inkRatio: (digitIsDark?dark:bright)/N};
}

function dilateOnce(mask, W, H){
  const out = new Uint8Array(mask.length);
  for(let y=0;y<H;y++){
    const yW=y*W;
    for(let x=0;x<W;x++){
      let v=0;
      for(let dy=-1;dy<=1 && !v;dy++){
        const yy=y+dy; if(yy<0||yy>=H) continue;
        const yyW=yy*W;
        for(let dx=-1;dx<=1;dx++){
          const xx=x+dx; if(xx<0||xx>=W) continue;
          if(mask[yyW+xx]){ v=1; break; }
        }
      }
      out[yW+x]=v;
    }
  }
  return out;
}

// セグメント窓（セグを“横断”する形の小領域）で、インク比を測る
function segmentRatios(mask, W, H){
  const rects = [
    // a
    [0.22,0.05, 0.78,0.18],
    // b
    [0.72,0.18, 0.92,0.46],
    // c
    [0.72,0.56, 0.92,0.84],
    // d
    [0.22,0.82, 0.78,0.95],
    // e
    [0.08,0.56, 0.28,0.84],
    // f
    [0.08,0.18, 0.28,0.46],
    // g
    [0.22,0.44, 0.78,0.56],
  ];
  const ratios = new Float32Array(7);
  for(let i=0;i<7;i++){
    let [x0,y0,x1,y1]=rects[i];
    const ix0=Math.max(0, Math.min(W-1, Math.floor(x0*W)));
    const ix1=Math.max(ix0+1, Math.min(W, Math.ceil(x1*W)));
    const iy0=Math.max(0, Math.min(H-1, Math.floor(y0*H)));
    const iy1=Math.max(iy0+1, Math.min(H, Math.ceil(y1*H)));
    let sum=0, cnt=0;
    for(let y=iy0;y<iy1;y++){
      const yW=y*W;
      for(let x=ix0;x<ix1;x++){
        sum += mask[yW+x];
        cnt++;
      }
    }
    ratios[i]= cnt? (sum/cnt) : 0;
  }
  return ratios;
}

function scoreBits(bits, ratios){
  let s=0;
  for(let i=0;i<7;i++){
    const b = bits.charCodeAt(i)===49; // '1'
    const r = ratios[i];
    s += b ? r : (1-r);
  }
  return s/7;
}

function classifyDigitBySegments(raw, W, H){
  const {mask, thr, inkRatio} = maskFromRaw(raw, W, H);
  const blankInk = parseFloat(segBlankInkEl.value||"0.02");
  if(inkRatio < blankInk){
    return {ch:"", conf:0.95, thr, inkRatio, ratios:null, best:0.95, second:0.0};
  }

  let m = mask;
  if(segBoldEl.checked){
    m = dilateOnce(m,W,H);
  }
  const ratios = segmentRatios(m,W,H);

  let best = -1, second=-1, bestCh="?", bestBits=null;
  for(const p of SEG_PATTERNS){
    const sc = scoreBits(p.bits, ratios);
    if(sc > best){ second=best; best=sc; bestCh=p.ch; bestBits=p.bits; }
    else if(sc > second){ second=sc; }
  }
  const gap = Math.max(0, best - (second<0?0:second));
  const conf = Math.max(0, Math.min(1, best * (0.65 + 0.35*Math.min(1, gap*3.0))));
  return {ch:bestCh, conf, thr, inkRatio, ratios, best, second, bits:bestBits};
}

async function predictDigitsWithSegments(srcCanvas, nDigits){
  const my = parseInt(myEl.value||"0",10);
  const y0 = Math.floor(srcCanvas.height * (my/100));
  const hh = Math.max(8, Math.floor(srcCanvas.height * (1 - 2*(my/100))));

  const split = (autoSplitEl.checked? splitDigitsByProjection(srcCanvas, nDigits, y0, hh) : {boxes:null, dbg:"split=off"});
  let useBoxes = split.boxes;
  if(!useBoxes){
    useBoxes=[];
    const w = srcCanvas.width/nDigits;
    for(let i=0;i<nDigits;i++) useBoxes.push({x:Math.floor(i*w), w:Math.floor(w), c:1.0});
  }

  const W=64, H=64;
  let s="";
  let minConf=1.0;
  for(let i=0;i<nDigits;i++){
    const pv = digCanvases[i];
    const b = useBoxes[Math.min(i, useBoxes.length-1)];
    const x0 = Math.max(0, Math.min(srcCanvas.width-1, b.x));
    const ww = Math.max(2, Math.min(srcCanvas.width-x0, b.w));
    const {raw} = cropDigitToArray(pv, srcCanvas, x0, y0, ww, hh, W, H);
    const r = classifyDigitBySegments(raw, W, H);
    const ch = r.ch;
    s += (ch===""?"0":ch); // blankは0扱い（先頭0が付くだけで数値は同じ）
    minConf = Math.min(minConf, r.conf);
    digMeta[i].textContent = `#${i+1}: seg=${ch||"□"} p=${r.conf.toFixed(2)} ink=${(r.inkRatio*100).toFixed(1)}%`;
  }
  const text = toCandidateString(s);
  return {text, conf:minConf, debug:`seg ${split.dbg} (minConf=${minConf.toFixed(2)})`};
}

function setGammaContrast(x){
  const g = parseFloat(gammaEl.value||"1.0");
  const c = parseFloat(contrastEl.value||"1.0");
  let y = x;
  if(g !== 1.0) y = Math.pow(Math.max(0,Math.min(1,y)), 1.0/g);
  if(c !== 1.0) y = Math.max(0,Math.min(1,(y-0.5)*c + 0.5));
  return y;
}
btnCopy.onclick=async()=>{
  const t=stableText||outEl.textContent;
  if(!t||t==="—") return;
  try{ await navigator.clipboard.writeText(t); }
  catch(_){ prompt("コピーして使ってください:", t); }
};

// ===== ML model (digit classifier) =====
let model=null;
let modelReady=false;

async function initTF(){
  try{
    if(wasmEl.checked){
      const wasmPath = "https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@4.20.0/dist/";
      tf.wasm.setWasmPaths(wasmPath);
      await tf.setBackend("wasm");
    }else{
      await tf.setBackend("webgl");
    }
    await tf.ready();
    return true;
  }catch(e){
    console.log(e);
    return false;
  }
}
async function loadModel(url){
  mlStateEl.textContent="ml: loading…";
  const ok = await initTF();
  if(!ok){ mlStateEl.textContent="ml: tf init failed"; return false; }
  try{
    model = await tf.loadLayersModel(url, {strict:true});
    const ish = model.inputs[0].shape; // [null,h,w,1]
    const h = ish[1]||32, w = ish[2]||32;
    tf.tidy(()=>model.predict(tf.zeros([1,h,w,1])).dispose());
    modelReady=true;
    mlStateEl.textContent=`ml: ready (backend=${tf.getBackend()} url=${url})`;
    return true;
  }catch(e){
    modelReady=false;
    mlStateEl.textContent="ml: load failed: "+(e?.message||e);
    return false;
  }
}
btnLoadModel.onclick=async()=>{
  const url = localStorage.getItem(LS.model) || "./model/model.json";
  const ok = await loadModel(url);
  if(ok) localStorage.setItem(LS.model, url);
};

// ==== digit preview UI ====
let digCanvases=[], digMeta=[];
function buildDigitPreview(){
  const n = parseInt(digitsEl.value,10);
  digPrev.innerHTML="";
  digCanvases=[]; digMeta=[];
  for(let i=0;i<n;i++){
    const card=document.createElement("div");
    card.className="digcard";
    const c=document.createElement("canvas");
    c.width=64; c.height=64;
    const m=document.createElement("div");
    m.className="digmeta mono";
    m.textContent=`#${i+1}: —`;
    card.appendChild(c);
    card.appendChild(m);
    digPrev.appendChild(card);
    digCanvases.push(c);
    digMeta.push(m);
  }
}

// ===== preprocessing utilities =====
function otsuThreshold(grayArr){
  const hist = new Uint32Array(256);
  for(let i=0;i<grayArr.length;i++){
    const v = Math.max(0, Math.min(255, (grayArr[i]*255)|0));
    hist[v]++;
  }
  const total = grayArr.length;
  let sum=0;
  for(let i=0;i<256;i++) sum += i*hist[i];

  let sumB=0, wB=0, wF=0;
  let varMax=0, threshold=128;

  for(let t=0;t<256;t++){
    wB += hist[t];
    if(wB===0) continue;
    wF = total - wB;
    if(wF===0) break;
    sumB += t*hist[t];
    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;
    const varBetween = wB*wF*(mB-mF)*(mB-mF);
    if(varBetween > varMax){
      varMax = varBetween;
      threshold = t;
    }
  }
  return threshold/255.0;
}

function grayFromCanvas(cnv){
  const ctx = cnv.getContext("2d",{willReadFrequently:true});
  const {width:w,height:h}=cnv;
  const d = ctx.getImageData(0,0,w,h).data;
  const arr = new Float32Array(w*h);
  for(let i=0,p=0;i<arr.length;i++,p+=4){
    const r=d[p], g=d[p+1], b=d[p+2];
    let x = (0.299*r + 0.587*g + 0.114*b) / 255.0;
    x = setGammaContrast(x);
    arr[i]=x;
  }
  return {arr,w,h};
}

// 自動桁分割：縦投影で“インクのある列”を run-length で抽出
function autoSplitBoxes(srcCanvas, nDigits){
  // scale ROI to manageable width
  const targetW = Math.max(120, Math.min(600, parseInt(splitWEl.value||"320",10)));
  const scale = targetW / srcCanvas.width;
  const w = targetW;
  const h = Math.max(40, Math.floor(srcCanvas.height * scale));
  seg.width=w; seg.height=h;
  ctxS.imageSmoothingEnabled = true;
  ctxS.clearRect(0,0,w,h);
  ctxS.drawImage(srcCanvas, 0,0, srcCanvas.width, srcCanvas.height, 0,0, w,h);

  const {arr:gray} = grayFromCanvas(seg);

  // decide invert for segmentation
  let doInv = autoInvEl.checked && (gray.reduce((a,b)=>a+b,0)/gray.length > 0.62);

  // binarize for projection
  const thr = otsuThreshold(gray);
  const bin = new Uint8Array(gray.length);
  for(let i=0;i<gray.length;i++){
    let v = (gray[i] < thr) ? 1 : 0; // dark=ink
    if(doInv) v = 1 - v;
    bin[i]=v;
  }

  const colPct = parseFloat(colPctEl.value||"6.0")/100.0; // percent of rows
  const colMin = Math.max(1, Math.floor(h * colPct));

  const colSum = new Uint16Array(w);
  for(let x=0;x<w;x++){
    let s=0;
    for(let y=0;y<h;y++){
      s += bin[y*w + x];
    }
    colSum[x]=s;
  }

  // active columns
  const active = new Uint8Array(w);
  for(let x=0;x<w;x++) active[x] = colSum[x] >= colMin ? 1 : 0;

  // runs
  const runs=[];
  let x=0;
  while(x<w){
    while(x<w && !active[x]) x++;
    if(x>=w) break;
    let x1=x;
    while(x<w && active[x]) x++;
    let x2=x-1;
    runs.push([x1,x2]);
  }

  // filter tiny
  const minRun = Math.max(2, parseInt(minRunEl.value||"10",10));
  let filtered = runs.filter(r => (r[1]-r[0]+1) >= minRun);

  // merge near gaps (digit might be split by inner hole)
  const mergeGap = Math.max(0, parseInt(mergeGapEl.value||"6",10));
  const merged=[];
  for(const r of filtered){
    if(!merged.length){ merged.push(r.slice()); continue; }
    const last=merged[merged.length-1];
    if(r[0]-last[1] <= mergeGap){
      last[1]=r[1];
    }else{
      merged.push(r.slice());
    }
  }

  // if too many, keep widest nDigits (ignore small text like "kg")
  let chosen = merged;
  if(chosen.length > nDigits){
    chosen = chosen
      .map(r=>({r, w:(r[1]-r[0]+1)}))
      .sort((a,b)=>b.w-a.w)
      .slice(0,nDigits)
      .map(o=>o.r)
      .sort((a,b)=>a[0]-b[0]);
  }

  // if too few, fallback equal split
  if(chosen.length < nDigits){
    const ww = srcCanvas.width;
    const step = ww / nDigits;
    const boxes=[];
    for(let i=0;i<nDigits;i++){
      const x1=Math.floor(i*step);
      const x2=Math.floor((i+1)*step)-1;
      boxes.push([x1,x2]);
    }
    return {boxes, debug:`split=fallback runs=${merged.length}`};
  }

  // map back to original srcCanvas coords
  const boxes = chosen.map(r=>{
    const x1 = Math.floor(r[0] / scale);
    const x2 = Math.floor((r[1]+1) / scale) - 1;
    return [clamp(x1,0,srcCanvas.width-1), clamp(x2,0,srcCanvas.width-1)];
  });

  return {boxes, debug:`split=auto runs=${merged.length} used=${boxes.length} inv=${doInv?1:0}`};
}

// digit crop → tensor + preview
function cropDigitToArray(previewCanvas, srcCanvas, sx, sy, sw, sh, outW, outH){
  const pctx = previewCanvas.getContext("2d",{willReadFrequently:true});
  pctx.imageSmoothingEnabled = false;
  pctx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  pctx.drawImage(srcCanvas, sx,sy,sw,sh, 0,0, previewCanvas.width, previewCanvas.height);

  dig.width=outW; dig.height=outH;
  ctxD.imageSmoothingEnabled = true;
  ctxD.clearRect(0,0,outW,outH);
  ctxD.drawImage(srcCanvas, sx,sy,sw,sh, 0,0,outW,outH);

  const d = ctxD.getImageData(0,0,outW,outH).data;
  const arr = new Float32Array(outW*outH);
  for(let i=0,p=0;i<arr.length;i++,p+=4){
    const r=d[p], g=d[p+1], b=d[p+2];
    let x = (0.299*r + 0.587*g + 0.114*b) / 255.0;
    x = setGammaContrast(x);
    arr[i]=x;
  }

  // apply preMode on model input
  const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
  let doAutoInvert = autoInvEl.checked && (mean > 0.62);
  let preMode = preModeEl.value;
  if(preMode==="invert") doAutoInvert = true;

  if(preMode==="otsu" || preMode==="otsu_inv"){
    const thr = otsuThreshold(arr);
    for(let i=0;i<arr.length;i++) arr[i] = (arr[i] < thr) ? 1.0 : 0.0;
    if(preMode==="otsu_inv") doAutoInvert = !doAutoInvert;
  }
  if(doAutoInvert){
    for(let i=0;i<arr.length;i++) arr[i] = 1.0 - arr[i];
  }

  // norm
  if(!norm01El.checked){
    for(let i=0;i<arr.length;i++) arr[i] = arr[i]*255.0; // rarely needed
  }
  return {arr, mean, inv:doAutoInvert?1:0};
}

function toCandidateString(s){
  if(decEl.value==="last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
    const v=parseFloat(s);
    if(!Number.isNaN(v)) s = v.toFixed(1);
  }
  s = toFixed1dp(s);
  return s;
}

async function predictDigitsWithModel(srcCanvas, nDigits){
  if(!modelReady) return {text:null, conf:0, debug:"ml-not-ready"};
  const ish = model.inputs[0].shape;
  const H = ish[1]||32, W = ish[2]||32;

  const w0 = srcCanvas.width, h0 = srcCanvas.height;
  const my = Math.floor(h0 * (parseInt(myEl.value,10)/100));
  const y0 = my;
  const hh = Math.max(10, h0 - my*2);

  // decide x boxes
  let boxes, splitDebug;
  if(autoSplitEl.checked){
    const res = autoSplitBoxes(srcCanvas, nDigits);
    boxes = res.boxes;
    splitDebug = res.debug;
  }else{
    const step = w0 / nDigits;
    boxes = Array.from({length:nDigits}, (_,i)=>[Math.floor(i*step), Math.floor((i+1)*step)-1]);
    splitDebug = "split=equal";
  }

  // run inference per digit
  let s="", confs=[];
  let invAny=0;
  for(let i=0;i<nDigits;i++){
    const [x1,x2]=boxes[i];
    const dw = Math.max(2, x2-x1+1);
    const sx = x1;

    const preview = digCanvases[i];
    const {arr, inv} = cropDigitToArray(preview, srcCanvas, sx, y0, dw, hh, W, H);
    invAny |= inv;

    const t = tf.tensor4d(arr, [1,H,W,1]);
    const p = tf.tidy(()=>{
      const y = model.predict(t);
      const a = y.dataSync();
      return Array.from(a);
    });
    t.dispose();

    let bestI=0, bestV=p[0];
    for(let k=1;k<p.length;k++){ if(p[k]>bestV){bestV=p[k]; bestI=k;} }

    // class 10 = blank（学習に入れている前提）
    if(bestI===10) s += ""; else s += String(bestI);
    confs.push(bestV);
    digMeta[i].textContent = `#${i+1}: cls=${bestI} p=${bestV.toFixed(2)} box=[${x1},${x2}]`;
  }

  let text = toCandidateString(s);
  const ok=/^[0-9]+(\.[0-9]+)?$/.test(text);
  const conf = confs.length ? confs.reduce((a,b)=>a+b,0)/confs.length : 0;
  return {text: ok?text:null, conf, debug:`${splitDebug} premode=${preModeEl.value} invAny=${invAny}`};
}

// ===== stabilizer =====
let lastCand=null, consec=0, stableText=null, stableConf=0, lastOkAt=0;
function resetStabilizer(){ lastCand=null; consec=0; stableText=null; stableConf=0; lastOkAt=0; setLamp("yellow"); }

// ===== loop =====
let lastAnalyzeAt=0;
function loop(){
  const now=performance.now();
  const interval=parseInt(anMsEl.value,10);

  ctxO.clearRect(0,0,overlay.width,overlay.height);

  const rx=Math.floor(ROI.x*overlay.width);
  const ry=Math.floor(ROI.y*overlay.height);
  const rw=Math.floor(ROI.w*overlay.width);
  const rh=Math.floor(ROI.h*overlay.height);

  ctxO.strokeStyle='rgba(255,0,0,.95)'; ctxO.lineWidth=3;
  ctxO.strokeRect(rx+1,ry+1,rw-2,rh-2);

  if(now-lastAnalyzeAt < interval){
    rafId=requestAnimationFrame(loop);
    return;
  }
  lastAnalyzeAt=now;

  work.width=rw; work.height=rh;
  ctxW.drawImage(video, rx, ry, rw, rh, 0, 0, rw, rh);

  const nd=parseInt(digitsEl.value,10);

  if(inflight){
    rafId=requestAnimationFrame(loop);
    return;
  }
  inflight=true;

  const needFallback = parseFloat(segFallbackEl.value||"0.55");

  if(useSegEl.checked){
    predictDigitsWithSegments(work, nd).then(segRes=>{
      if(useMLEl.checked && modelReady && (!segRes.text || segRes.conf < needFallback)){
        return predictDigitsWithModel(work, nd).then(mlRes=>{
          applyCandidate(mlRes.text, mlRes.conf, `ml | ${mlRes.debug} (seg conf=${segRes.conf.toFixed(2)})`);
        });
      }else{
        applyCandidate(segRes.text, segRes.conf, `seg | ${segRes.debug}`);
      }
    }).catch(e=>{
      console.warn("seg err", e);
      if(useMLEl.checked && modelReady){
        predictDigitsWithModel(work, nd).then(mlRes=>{
          applyCandidate(mlRes.text, mlRes.conf, `ml | ${mlRes.debug} (seg err)`);
        }).catch(err2=>{
          console.warn("ml err", err2);
          applyCandidate(null,0,`err seg+ml`);
        });
      }else{
        applyCandidate(null,0,`err seg`);
      }
    }).finally(()=>{ inflight=false; });
  }else if(useMLEl.checked && modelReady){
    predictDigitsWithModel(work, nd).then(res=>{
      applyCandidate(res.text, res.conf, `ml | ${res.debug}`);
    }).catch(e=>{
      console.warn("ml err", e);
      applyCandidate(null,0,`err ml`);
    }).finally(()=>{ inflight=false; });
  }else{
    applyCandidate(null,0,`no recognizer`);
    inflight=false;
  }

  rafId=requestAnimationFrame(loop);
}

function applyCandidate(candidate, conf, debug){
  candLine.textContent = `候補: ${candidate ?? "—"} (conf=${conf.toFixed(2)} / ${debug})`;

  const needFrames=parseInt(needFramesEl.value,10);
  const needConf=parseFloat(needConfEl.value);
  const graceMs=parseInt(graceMsEl.value,10);

  let acceptable = (candidate !== null) && (conf >= needConf) && passesGate(candidate);

  if(acceptable){
    lastOkAt = performance.now();
    if(candidate === lastCand) consec++;
    else { lastCand=candidate; consec=1; }

    if(!stabilizeEl.checked){
      stableText=candidate; stableConf=conf; outEl.textContent=stableText; setLamp("green");
    }else{
      if(consec >= needFrames){
        stableText=candidate; stableConf=conf; outEl.textContent=stableText; setLamp("green");
      }else{
        if(!holdEl.checked) outEl.textContent="—";
        else if(stableText) outEl.textContent=stableText;
        setLamp("yellow");
      }
    }
  }else{
    lastCand=null; consec=0;
    const now=performance.now();
    const withinGrace = stableText && (now - lastOkAt) <= graceMs;
    if(withinGrace && holdEl.checked){
      outEl.textContent=stableText;
      setLamp("green");
    }else{
      if(!holdEl.checked) outEl.textContent="—";
      else if(stableText) outEl.textContent=stableText;
      setLamp("yellow");
    }
  }

  const camLabel = selCam.selectedOptions?.[0]?.textContent || "";
  dbgEl.textContent =
    `ml=${useMLEl.checked?1:0} ready=${modelReady?1:0} ${debug} | `+
    `conf=${conf.toFixed(2)} needConf=${Number(needConfEl.value).toFixed(2)} `+
    `stable=${stabilizeEl.checked?1:0} consec=${consec}/${needFrames} grace=${graceMs}ms | cam="${camLabel}"`;
}

// init
navigator.mediaDevices?.addEventListener?.('devicechange', ()=>listCams({preserve:true,autoPickBack:true}));
listCams({preserve:true,autoPickBack:true}).catch(()=>{});
setRoiBox(); syncLabels(); buildDigitPreview(); setLamp("yellow"); resetStabilizer();
</script>
</body>
</html>
