<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>7セグ読み取り v19（7窓のみ・横断窓）</title>
<style>
  body{font-family:system-ui,-apple-system,sans-serif;margin:0;background:#111;color:#eee}
  .wrap{max-width:1100px;margin:0 auto;padding:10px;display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  button,select,input{font-size:16px;padding:8px 10px}
  .btn{background:#2a2a2a;border:1px solid #3a3a3a;color:#fff;border-radius:10px}
  .btn:active{transform:translateY(1px)}
  .chip{display:flex;align-items:center;gap:6px;background:#1c1c1c;border:1px solid #2a2a2a;padding:6px 8px;border-radius:999px}
  .stage{position:relative;width:100%;aspect-ratio:16/9;background:#000;overflow:hidden;border-radius:12px}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  .panel{background:#1b1b1b;border-radius:12px;padding:10px}
  .big{font-size:42px;font-weight:900;letter-spacing:.5px;display:flex;align-items:center;gap:10px}
  .lamp{width:12px;height:12px;border-radius:999px;background:#666;box-shadow:0 0 0 2px rgba(255,255,255,.08) inset}
  .lamp.green{background:#1fe36d}
  .lamp.yellow{background:#ffd34d}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
  .sub{color:#cfcfcf;font-size:14px;margin-top:4px}
  details{background:#151515;border-radius:12px;padding:8px 10px}
  details summary{cursor:pointer}
  .kv{display:grid;grid-template-columns:170px 1fr 70px;gap:8px;align-items:center;margin-top:8px}
  .kv label{color:#bbb;font-size:13px}
  .kv input[type=range]{width:100%}
  .hint{color:#bbb;font-size:13px;line-height:1.45}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:10px}
  @media (max-width:920px){.grid{grid-template-columns:1fr}}
  .smallinp{width:90px;padding:6px 8px;border-radius:8px;border:1px solid #333;background:#101010;color:#fff}
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <button id="btnStart" class="btn">カメラ開始</button>
    <button id="btnStop" class="btn" disabled>停止</button>

    <label>カメラ</label>
    <select id="selCam"></select>
    <span class="chip"><input id="lockBack" type="checkbox" checked>背面固定</span>

    <label>解析(ms)</label>
    <input id="anMs" type="range" min="80" max="400" step="10" value="160">
    <span id="anMsVal" class="mono">160</span>

    <label>桁</label>
    <select id="digits">
      <option value="4" selected>4桁</option>
      <option value="5">5桁</option>
    </select>

    <label>小数点</label>
    <select id="decimal">
      <option value="last" selected>最後の1桁前（xxx.x）</option>
      <option value="none">なし</option>
    </select>

    <span class="chip"><input id="stabilize" type="checkbox" checked>ちらつき防止</span>
    <span class="chip"><input id="hold" type="checkbox" checked>確定値ホールド</span>
  </div>

  <details open>
    <summary>合わせ込み（横断窓ガイド）</summary>
    <div class="hint" style="margin-top:8px">
      画面に表示される <b>4桁分の横断窓</b>（細い枠）に、体重計の表示窓を<b>ぴったり重ねて</b>ください。
      これがズレると誤読します。
    </div>
    <div class="kv"><label>ガイドX（%）</label><input id="gx" type="range" min="0" max="1" step="0.01"><span id="gxv"></span></div>
    <div class="kv"><label>ガイドY（%）</label><input id="gy" type="range" min="0" max="1" step="0.01"><span id="gyv"></span></div>
    <div class="kv"><label>ガイドW（%）</label><input id="gw" type="range" min="0.20" max="1" step="0.01"><span id="gwv"></span></div>
    <div class="kv"><label>ガイドH（%）</label><input id="gh" type="range" min="0.10" max="0.70" step="0.01"><span id="ghv"></span></div>
    <div class="row" style="margin-top:8px">
      <button id="btnGuideReset" class="btn" type="button">ガイド初期化</button>
      <span class="chip"><input id="showWindows" type="checkbox" checked>横断窓を表示</span>
      <span class="chip"><input id="showDigitBoxes" type="checkbox" checked>桁枠を表示</span>
    </div>
  </details>

  <details open>
    <summary>前処理（軽い・iPhone向け）</summary>
    <div class="row" style="margin-top:8px">
      <span class="chip"><input id="invert" type="checkbox" checked>反転（黒数字用）</span>
      <span class="chip"><input id="autoOtsu" type="checkbox" checked>自動2値化（Otsu）</span>
      <span class="chip">Otsuオフセット <input id="otsuOff" class="smallinp" type="number" step="1" value="-15"></span>
      <span class="chip"><input id="dilate" type="checkbox" checked>太らせる（細いセグ対策）</span>
      <span class="chip">太さ <input id="dilateN" class="smallinp" type="number" min="1" max="3" value="1"></span>
      <span class="chip">窓サイズ倍率 <input id="winScale" type="range" min="0.60" max="1.80" step="0.05" value="1.00" style="width:140px"></span>
      <span id="winScaleVal" class="mono">1.00</span>
    </div>
    <div class="kv"><label>セグ判定しきい値（黒率）</label><input id="segThr" type="range" min="0.10" max="0.60" step="0.01" value="0.28"><span id="segThrVal"></span></div>
    <div class="kv"><label>空白判定（全体黒率）</label><input id="blankThr" type="range" min="0.00" max="0.10" step="0.005" value="0.02"><span id="blankThrVal"></span></div>
    <div class="hint" style="margin-top:8px">
      ・黒数字（明るい背景）なら <b>反転ON</b> が基本。<br>
      ・読めない時は、まず <b>seg判定</b> を 0.22〜0.38 で調整 → 次に Otsuオフセット（-40〜+20）。<br>
    </div>
  </details>

  <details open>
    <summary>安定化（確定表示）</summary>
    <div class="kv"><label>確定に必要な連続フレーム</label><input id="needFrames" type="range" min="1" max="20" step="1" value="6"><span id="needFramesVal"></span></div>
    <div class="kv"><label>失敗許容（ms）</label><input id="graceMs" type="range" min="0" max="2500" step="50" value="900"><span id="graceMsVal"></span></div>
    <div class="row" style="margin-top:8px">
      <span class="chip">範囲 <input id="minVal" class="smallinp" type="number" step="0.1" value="10"> ～ <input id="maxVal" class="smallinp" type="number" step="0.1" value="250"></span>
      <span class="chip"><input id="force1dp" type="checkbox" checked>小数1桁に揃える</span>
    </div>
  </details>

  <div class="grid">
    <div class="stage">
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
    </div>

    <div class="panel">
      <div><b>表示（確定）</b></div>
      <div class="big"><span id="lamp" class="lamp yellow"></span><span id="out">—</span></div>
      <div id="cand" class="sub mono">候補: —</div>
      <div id="dbg" class="hint mono" style="margin-top:8px"></div>
      <div class="row" style="margin-top:10px">
        <button id="btnCopy" class="btn" type="button">確定値をコピー</button>
      </div>
      <div class="hint" style="margin-top:8px">
        コツ：ガイド（赤）に表示窓を合わせたら、以後は体重計とiPhoneを固定。<br>
        それでもチラつくなら「確定に必要な連続フレーム」を 8〜12 に。
      </div>
    </div>
  </div>

  <canvas id="work" style="display:none"></canvas>
</div>

<script>
const $=id=>document.getElementById(id);
const video=$("video"), overlay=$("overlay"), work=$("work");
const ctxO=overlay.getContext("2d",{willReadFrequently:true});
const ctxW=work.getContext("2d",{willReadFrequently:true});

const btnStart=$("btnStart"), btnStop=$("btnStop"), selCam=$("selCam"), lockBack=$("lockBack");
const anMs=$("anMs"), anMsVal=$("anMsVal"), digitsEl=$("digits"), decEl=$("decimal");
const stabilizeEl=$("stabilize"), holdEl=$("hold");

const gx=$("gx"), gy=$("gy"), gw=$("gw"), gh=$("gh");
const gxv=$("gxv"), gyv=$("gyv"), gwv=$("gwv"), ghv=$("ghv");
const btnGuideReset=$("btnGuideReset"), showWindows=$("showWindows"), showDigitBoxes=$("showDigitBoxes");

const invertEl=$("invert"), autoOtsu=$("autoOtsu"), otsuOff=$("otsuOff"), dilate=$("dilate"), dilateN=$("dilateN");
const winScale=$("winScale"), winScaleVal=$("winScaleVal");
const segThr=$("segThr"), segThrVal=$("segThrVal"), blankThr=$("blankThr"), blankThrVal=$("blankThrVal");

const needFrames=$("needFrames"), needFramesVal=$("needFramesVal"), graceMs=$("graceMs"), graceMsVal=$("graceMsVal");
const minVal=$("minVal"), maxVal=$("maxVal"), force1dp=$("force1dp");

const lamp=$("lamp"), out=$("out"), cand=$("cand"), dbg=$("dbg"), btnCopy=$("btnCopy");

let stream=null, rafId=null, lastAnalyzeAt=0;

const LS={
  cam:"sevenseg_cam_deviceid",
  lock:"sevenseg_lockback",
  guide:"sevenseg_guide_v18",
  an:"sevenseg_anms_v18",
  digits:"sevenseg_digits_v18",
  dec:"sevenseg_dec_v18",
  inv:"sevenseg_inv_v18",
  otsu:"sevenseg_otsu_v18",
  otsuOff:"sevenseg_otsuOff_v18",
  dil:"sevenseg_dil_v18",
  diln:"sevenseg_diln_v18",
  wins:"sevenseg_winscale_v19",
  seg:"sevenseg_segthr_v18",
  blank:"sevenseg_blankthr_v18",
  nf:"sevenseg_needframes_v18",
  gm:"sevenseg_grace_v18",
  minv:"sevenseg_minv_v18",
  maxv:"sevenseg_maxv_v18",
  force:"sevenseg_force1dp_v18",
  showW:"sevenseg_showwin_v18",
  showB:"sevenseg_showbox_v18",
  stab:"sevenseg_stab_v18",
  hold:"sevenseg_hold_v18",
};

function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function clamp01(v){return clamp(v,0,1)}
function setLamp(state){
  lamp.classList.remove("green","yellow");
  if(state==="green") lamp.classList.add("green");
  else lamp.classList.add("yellow");
}
function syncLabels(){
  anMsVal.textContent=String(anMs.value);
  winScaleVal.textContent=Number(winScale.value).toFixed(2);
  segThrVal.textContent=Number(segThr.value).toFixed(2);
  blankThrVal.textContent=Number(blankThr.value).toFixed(3);
  needFramesVal.textContent=String(needFrames.value);
  graceMsVal.textContent=String(graceMs.value);

  gxv.textContent=(+gx.value).toFixed(2);
  gyv.textContent=(+gy.value).toFixed(2);
  gwv.textContent=(+gw.value).toFixed(2);
  ghv.textContent=(+gh.value).toFixed(2);
}
function loadGuide(){
  const def={x:0.18,y:0.44,w:0.64,h:0.20};
  try{
    const s=localStorage.getItem(LS.guide);
    if(!s) return def;
    const o=JSON.parse(s);
    return {x:clamp01(+o.x),y:clamp01(+o.y),w:clamp(+o.w,0.20,1),h:clamp(+o.h,0.10,0.70)};
  }catch(_){return def}
}
let GUIDE=loadGuide();
function applyGuideToUI(){
  gx.value=GUIDE.x; gy.value=GUIDE.y; gw.value=GUIDE.w; gh.value=GUIDE.h;
  syncLabels();
}
function saveGuide(){
  localStorage.setItem(LS.guide, JSON.stringify(GUIDE));
}

function restore(){
  lockBack.checked=(localStorage.getItem(LS.lock)??"1")==="1";
  anMs.value=(localStorage.getItem(LS.an)??"160");
  digitsEl.value=(localStorage.getItem(LS.digits)??"4");
  decEl.value=(localStorage.getItem(LS.dec)??"last");

  invertEl.checked=(localStorage.getItem(LS.inv)??"1")==="1";
  autoOtsu.checked=(localStorage.getItem(LS.otsu)??"1")==="1";
  otsuOff.value=(localStorage.getItem(LS.otsuOff)??"-15");
  dilate.checked=(localStorage.getItem(LS.dil)??"1")==="1";
  dilateN.value=(localStorage.getItem(LS.diln)??"1");
  winScale.value=(localStorage.getItem(LS.wins)??"1.00");
  segThr.value=(localStorage.getItem(LS.seg)??"0.28");
  blankThr.value=(localStorage.getItem(LS.blank)??"0.02");

  needFrames.value=(localStorage.getItem(LS.nf)??"6");
  graceMs.value=(localStorage.getItem(LS.gm)??"900");
  minVal.value=(localStorage.getItem(LS.minv)??"10");
  maxVal.value=(localStorage.getItem(LS.maxv)??"250");
  force1dp.checked=(localStorage.getItem(LS.force)??"1")==="1";

  showWindows.checked=(localStorage.getItem(LS.showW)??"1")==="1";
  showDigitBoxes.checked=(localStorage.getItem(LS.showB)??"1")==="1";
  stabilizeEl.checked=(localStorage.getItem(LS.stab)??"1")==="1";
  holdEl.checked=(localStorage.getItem(LS.hold)??"1")==="1";

  GUIDE=loadGuide();
  applyGuideToUI();
}
restore();

function persist(){
  lockBack.onchange=()=>localStorage.setItem(LS.lock, lockBack.checked?"1":"0");
  anMs.oninput=()=>{localStorage.setItem(LS.an,anMs.value); syncLabels();}
  digitsEl.onchange=()=>localStorage.setItem(LS.digits, digitsEl.value);
  decEl.onchange=()=>localStorage.setItem(LS.dec, decEl.value);

  invertEl.onchange=()=>localStorage.setItem(LS.inv, invertEl.checked?"1":"0");
  autoOtsu.onchange=()=>localStorage.setItem(LS.otsu, autoOtsu.checked?"1":"0");
  otsuOff.onchange=()=>localStorage.setItem(LS.otsuOff, otsuOff.value);
  dilate.onchange=()=>localStorage.setItem(LS.dil, dilate.checked?"1":"0");
  dilateN.onchange=()=>localStorage.setItem(LS.diln, dilateN.value);
  winScale.oninput=()=>{localStorage.setItem(LS.wins, winScale.value); syncLabels();}
  segThr.oninput=()=>{localStorage.setItem(LS.seg, segThr.value); syncLabels();}
  blankThr.oninput=()=>{localStorage.setItem(LS.blank, blankThr.value); syncLabels();}

  needFrames.oninput=()=>{localStorage.setItem(LS.nf, needFrames.value); syncLabels();}
  graceMs.oninput=()=>{localStorage.setItem(LS.gm, graceMs.value); syncLabels();}
  minVal.onchange=()=>localStorage.setItem(LS.minv, minVal.value);
  maxVal.onchange=()=>localStorage.setItem(LS.maxv, maxVal.value);
  force1dp.onchange=()=>localStorage.setItem(LS.force, force1dp.checked?"1":"0");

  showWindows.onchange=()=>localStorage.setItem(LS.showW, showWindows.checked?"1":"0");
  showDigitBoxes.onchange=()=>localStorage.setItem(LS.showB, showDigitBoxes.checked?"1":"0");
  stabilizeEl.onchange=()=>localStorage.setItem(LS.stab, stabilizeEl.checked?"1":"0");
  holdEl.onchange=()=>localStorage.setItem(LS.hold, holdEl.checked?"1":"0");

  const bindGuide=(el,key)=>{
    el.addEventListener("input", ()=>{
      GUIDE[key]=parseFloat(el.value);
      if(key==="w") GUIDE.w=clamp(GUIDE.w,0.20,1);
      if(key==="h") GUIDE.h=clamp(GUIDE.h,0.10,0.70);
      GUIDE.x=clamp01(Math.min(GUIDE.x, 1-GUIDE.w));
      GUIDE.y=clamp01(Math.min(GUIDE.y, 1-GUIDE.h));
      saveGuide(); syncLabels();
    });
  };
  bindGuide(gx,"x"); bindGuide(gy,"y"); bindGuide(gw,"w"); bindGuide(gh,"h");
}
persist();

btnGuideReset.onclick=()=>{
  GUIDE={x:0.18,y:0.44,w:0.64,h:0.20};
  saveGuide();
  applyGuideToUI();
};

function isBackLabel(label){ return /(back|rear|environment|背面|リア|後ろ)/i.test(label||""); }

async function listCams({preserve=true,autoPickBack=true}={}){
  const prev=preserve?selCam.value:"";
  const saved=localStorage.getItem(LS.cam)||"";
  const devices=await navigator.mediaDevices.enumerateDevices();
  const cams=devices.filter(d=>d.kind==="videoinput");
  selCam.innerHTML="";
  cams.forEach((c,i)=>{
    const opt=document.createElement("option");
    opt.value=c.deviceId;
    opt.textContent=c.label||`Camera ${i+1}`;
    selCam.appendChild(opt);
  });
  if([...selCam.options].some(o=>o.value===prev)){ selCam.value=prev; return;}
  if([...selCam.options].some(o=>o.value===saved)){ selCam.value=saved; return;}
  if(autoPickBack && lockBack.checked){
    const back=[...selCam.options].find(o=>isBackLabel(o.textContent));
    if(back){ selCam.value=back.value; return; }
  }
  if(selCam.options.length) selCam.selectedIndex=0;
}
selCam.onchange=()=>localStorage.setItem(LS.cam, selCam.value||"");

async function startCamera(){
  await listCams({preserve:true,autoPickBack:false});
  try{
    const tmp=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:lockBack.checked?"environment":"user"}},audio:false});
    tmp.getTracks().forEach(t=>t.stop());
  }catch(e){}
  await listCams({preserve:true,autoPickBack:true});

  const deviceId=selCam.value||undefined;
  stream=await navigator.mediaDevices.getUserMedia({
    video:{
      deviceId: deviceId?{exact:deviceId}:undefined,
      facingMode: deviceId?undefined:{ideal:lockBack.checked?"environment":"user"},
      width:{ideal:1280}, height:{ideal:720}
    },
    audio:false
  });
  video.srcObject=stream;
  await video.play();

  btnStart.disabled=true;
  btnStop.disabled=false;

  overlay.width=video.videoWidth;
  overlay.height=video.videoHeight;

  resetStabilizer();
  loop();
}
function stopCamera(){
  cancelAnimationFrame(rafId); rafId=null;
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  video.pause(); video.srcObject=null;

  btnStart.disabled=false;
  btnStop.disabled=true;

  out.textContent="—";
  cand.textContent="候補: —";
  dbg.textContent="";
  setLamp("yellow");
}
btnStart.onclick=async()=>{ try{ await startCamera(); }catch(e){ alert("カメラ開始失敗: "+(e?.message||e)); } };
btnStop.onclick=()=>stopCamera();
selCam.onchange=async()=>{
  localStorage.setItem(LS.cam, selCam.value||"");
  if(!stream) return;
  stopCamera();
  await new Promise(r=>setTimeout(r,200));
  btnStart.onclick();
};

btnCopy.onclick=async()=>{
  const t=stableText||out.textContent;
  if(!t||t==="—") return;
  try{ await navigator.clipboard.writeText(t); }
  catch(_){ prompt("コピーして使ってください:", t); }
};

// ====== 7セグ辞書（a b c d e f g） ======
const DIGIT_MAP = new Map([
  ["1111110","0"],
  ["0110000","1"],
  ["1101101","2"],
  ["1111001","3"],
  ["0110011","4"],
  ["1011011","5"],
  ["1011111","6"],
  ["1110000","7"],
  ["1111111","8"],
  ["1111011","9"],
]);

function clampInt(v,a,b){ v=v|0; return Math.max(a,Math.min(b,v)); }

// ====== Otsu ======
function otsuThreshold(gray){
  const hist = new Uint32Array(256);
  for(let i=0;i<gray.length;i++){
    const v = clampInt(gray[i],0,255);
    hist[v]++;
  }
  const total = gray.length;
  let sum=0;
  for(let i=0;i<256;i++) sum += i*hist[i];

  let sumB=0, wB=0, wF=0;
  let varMax=0, thr=128;
  for(let t=0;t<256;t++){
    wB += hist[t];
    if(wB===0) continue;
    wF = total - wB;
    if(wF===0) break;
    sumB += t*hist[t];
    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;
    const vb = wB*wF*(mB-mF)*(mB-mF);
    if(vb > varMax){ varMax = vb; thr = t; }
  }
  return thr;
}

function binarize(imageData, w, h){
  const d=imageData.data;
  const g=new Uint8Array(w*h);
  for(let i=0,p=0;i<g.length;i++,p+=4){
    const r=d[p], gg=d[p+1], b=d[p+2];
    g[i] = (0.299*r + 0.587*gg + 0.114*b) | 0;
  }

  let thr=128;
  if(autoOtsu.checked){
    thr = otsuThreshold(g);
    thr = clampInt(thr + (parseInt(otsuOff.value||"0",10)||0), 0, 255);
  }else{
    thr = clampInt(parseInt(otsuOff.value||"128",10)||128, 0, 255);
  }

  const bin=new Uint8Array(w*h);
  const inv=invertEl.checked;
  for(let i=0;i<g.length;i++){
    let v = (g[i] < thr) ? 1 : 0; // dark=ink
    if(inv) v = 1 - v;
    bin[i]=v;
  }

  if(dilate.checked){
    const n=clampInt(parseInt(dilateN.value||"1",10),1,3);
    for(let it=0;it<n;it++){
      const src=bin.slice();
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          const i=y*w+x;
          if(src[i]) continue;
          if(src[i-1]||src[i+1]||src[i-w]||src[i+w]||src[i-w-1]||src[i-w+1]||src[i+w-1]||src[i+w+1]){
            bin[i]=1;
          }
        }
      }
    }
  }

  return {bin, thr};
}

function blackRatio(bin, w, x0,y0,x1,y1){
  x0=clampInt(Math.floor(x0),0,w-1);
  x1=clampInt(Math.floor(x1),0,w);
  y0=Math.max(0,Math.floor(y0));
  y1=Math.max(0,Math.floor(y1));
  if(x1<=x0||y1<=y0) return 0;
  let sum=0, cnt=0;
  for(let y=y0;y<y1;y++){
    const row=y*w;
    for(let x=x0;x<x1;x++){
      sum += bin[row+x];
      cnt++;
    }
  }
  return cnt? (sum/cnt) : 0;
}

function guideRect(){
  const w=overlay.width, h=overlay.height;
  const x=Math.floor(GUIDE.x*w);
  const y=Math.floor(GUIDE.y*h);
  const ww=Math.floor(GUIDE.w*w);
  const hh=Math.floor(GUIDE.h*h);
  return {x,y,w:ww,h:hh};
}

// ====== 7窓（1桁内の相対位置） ======
function segWindowsForDigit(dx,dy,dw,dh){
  // 「セグに沿う」窓ではなく、「セグを横断する」窓（断面）で黒率判定する
  // - 水平セグ(a,g,d) → 垂直の細長い窓で横断
  // - 垂直セグ(f,b,e,c) → 水平の細長い窓で横断
  const s = Math.max(0.60, Math.min(1.80, parseFloat(winScale?.value ?? "1.0")));

  const x0=dx, y0=dy, x1=dx+dw, y1=dy+dh;

  // 中心座標（7セグ表示の一般的な比率）
  const cx = x0 + dw*0.50;

  const yA = y0 + dh*0.18;
  const yG = y0 + dh*0.50;
  const yD = y0 + dh*0.82;

  const xL = x0 + dw*0.26;
  const xR = x0 + dw*0.74;

  const yU = y0 + dh*0.35;
  const yL = y0 + dh*0.65;

  // 窓サイズ（倍率で調整）
  // 水平セグを横断する窓：縦長（幅は小さめ、高さはセグ厚みを跨ぐ程度）
  const wH = dw*0.22*s;
  const hH = dh*0.18*s;

  // 垂直セグを横断する窓：横長
  const wV = dw*0.26*s;
  const hV = dh*0.16*s;

  function rect(cx,cy,w,h){
    let x=cx-w/2, y=cy-h/2;
    // digit内に収める
    x = Math.max(x0, Math.min(x, x1-w));
    y = Math.max(y0, Math.min(y, y1-h));
    return {x,y,w,h};
  }

  const a = rect(cx, yA, wH, hH);
  const g = rect(cx, yG, wH, hH);
  const d = rect(cx, yD, wH, hH);

  const f = rect(xL, yU, wV, hV);
  const b = rect(xR, yU, wV, hV);
  const e = rect(xL, yL, wV, hV);
  const c = rect(xR, yL, wV, hV);

  return {a,b,c,d,e,f,g};
}

function toCandidateString(s){
  if(decEl.value==="last"){
    if(s.length>=2) s = s.slice(0,-1) + "." + s.slice(-1);
  }
  if(force1dp.checked && s && !s.includes(".")) s = s + ".0";
  return s;
}

function passesGate(text){
  if(!text) return false;
  const v=parseFloat(text);
  if(Number.isNaN(v)) return false;
  const mn=parseFloat(minVal.value||"0"), mx=parseFloat(maxVal.value||"9999");
  return v>=mn && v<=mx;
}

function recognize(){
  const r=guideRect();
  work.width=r.w; work.height=r.h;
  ctxW.drawImage(video, r.x, r.y, r.w, r.h, 0,0, r.w, r.h);

  const img=ctxW.getImageData(0,0,r.w,r.h);
  const {bin, thr}=binarize(img, r.w, r.h);

  const nDigits=parseInt(digitsEl.value,10);
  const step=r.w / nDigits;

  const segT=parseFloat(segThr.value);
  const blankT=parseFloat(blankThr.value);

  let outStr="";
  const perDigitDbg=[];
  for(let i=0;i<nDigits;i++){
    const dx=i*step, dw=step, dy=0, dh=r.h;

    const inkAll = blackRatio(bin, r.w, dx, dy, dx+dw, dy+dh);
    if(inkAll < blankT){
      perDigitDbg.push(`#${i+1}: blank ink=${inkAll.toFixed(2)}`);
      continue;
    }

    const w7=segWindowsForDigit(dx,dy,dw,dh);
    const bits=[];
    for(const key of ["a","b","c","d","e","f","g"]){
      const ww=w7[key];
      const ink=blackRatio(bin, r.w, ww.x, ww.y, ww.x+ww.w, ww.y+ww.h);
      bits.push(ink >= segT ? "1":"0");
    }
    const pat=bits.join("");
    const digit = DIGIT_MAP.get(pat) ?? "?";
    outStr += digit;
    perDigitDbg.push(`#${i+1}: ${digit} pat=${pat} ink=${inkAll.toFixed(2)}`);
  }

  const candText = (/^[0-9?]+$/.test(outStr) && outStr.length>0) ? toCandidateString(outStr) : null;

  let conf=0;
  if(outStr && outStr.length){
    const okc=[...outStr].filter(ch=>ch!=="?").length;
    conf = okc / outStr.length;
  }

  return {text:candText, conf, thr, debug:perDigitDbg.join(" | ")};
}

// ====== 安定化 ======
let lastCand=null, consec=0, stableText=null, lastOkAt=0;
function resetStabilizer(){ lastCand=null; consec=0; stableText=null; lastOkAt=0; setLamp("yellow"); }

function applyCandidate(candidate, conf, thr, debug){
  cand.textContent = `候補: ${candidate ?? "—"} (conf=${conf.toFixed(2)} thr=${thr})`;
  const need=parseInt(needFrames.value,10);
  const grace=parseInt(graceMs.value,10);

  const acceptable = (candidate !== null) && (conf >= 0.75) && passesGate(candidate);

  if(acceptable){
    lastOkAt=performance.now();
    if(candidate===lastCand) consec++;
    else { lastCand=candidate; consec=1; }

    if(!stabilizeEl.checked){
      stableText=candidate; out.textContent=stableText; setLamp("green");
    }else{
      if(consec>=need){
        stableText=candidate; out.textContent=stableText; setLamp("green");
      }else{
        if(!holdEl.checked) out.textContent="—";
        else if(stableText) out.textContent=stableText;
        setLamp("yellow");
      }
    }
  }else{
    lastCand=null; consec=0;
    const now=performance.now();
    const withinGrace = stableText && (now - lastOkAt) <= grace;
    if(withinGrace && holdEl.checked){
      out.textContent=stableText;
      setLamp("green");
    }else{
      if(!holdEl.checked) out.textContent="—";
      else if(stableText) out.textContent=stableText;
      setLamp("yellow");
    }
  }

  const camLabel = selCam.selectedOptions?.[0]?.textContent || "";
  dbg.textContent =
    `mode=7windows | digits=${digitsEl.value} inv=${invertEl.checked?1:0} otsu=${autoOtsu.checked?1:0} off=${otsuOff.value} win=${Number(winScale.value).toFixed(2)} `+
    `dil=${dilate.checked?1:0} n=${dilateN.value} segThr=${Number(segThr.value).toFixed(2)} blankThr=${Number(blankThr.value).toFixed(3)} | `+
    `stable=${stabilizeEl.checked?1:0} consec=${consec}/${need} grace=${grace}ms | cam="${camLabel}"
`+
    debug;
}

function drawOverlay(){
  ctxO.clearRect(0,0,overlay.width,overlay.height);

  const r=guideRect();
  ctxO.strokeStyle="rgba(255,0,0,.95)";
  ctxO.lineWidth=3;
  ctxO.strokeRect(r.x+1,r.y+1,r.w-2,r.h-2);

  const nDigits=parseInt(digitsEl.value,10);
  const step=r.w/nDigits;

  if(showDigitBoxes.checked){
    ctxO.strokeStyle="rgba(255,0,0,.55)";
    ctxO.lineWidth=2;
    for(let i=1;i<nDigits;i++){
      const x=r.x + i*step;
      ctxO.beginPath(); ctxO.moveTo(x,r.y); ctxO.lineTo(x,r.y+r.h); ctxO.stroke();
    }
  }

  if(showWindows.checked){
    ctxO.fillStyle="rgba(255,255,0,.22)";
    ctxO.strokeStyle="rgba(255,255,0,.55)";
    ctxO.lineWidth=1;
    for(let i=0;i<nDigits;i++){
      const dx=r.x + i*step;
      const dy=r.y;
      const dw=step;
      const dh=r.h;
      const w7=segWindowsForDigit(dx,dy,dw,dh);
      for(const k of ["a","b","c","d","e","f","g"]){
        const w=w7[k];
        ctxO.fillRect(w.x,w.y,w.w,w.h);
        ctxO.strokeRect(w.x+0.5,w.y+0.5,w.w-1,w.h-1);
      }
    }
  }
}

function loop(){
  const now=performance.now();
  drawOverlay();

  const interval=parseInt(anMs.value,10);
  if(now-lastAnalyzeAt >= interval && stream){
    lastAnalyzeAt=now;
    const res=recognize();
    applyCandidate(res.text, res.conf, res.thr, res.debug);
  }
  rafId=requestAnimationFrame(loop);
}

navigator.mediaDevices?.addEventListener?.('devicechange', ()=>listCams({preserve:true,autoPickBack:true}));
listCams({preserve:true,autoPickBack:true}).catch(()=>{});
syncLabels();
</script>
</body>
</html>
